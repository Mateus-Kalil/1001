<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Debian Terminal | MKalil</title>
  <style>
    body {
      background: #000;
      color: #0f0;
      font-family: monospace;
      margin: 0;
      padding: 0;
      overflow: hidden;
    }
    #terminal {
      padding: 10px;
      white-space: pre-wrap;
      height: 100vh;
      overflow-y: auto;
    }
    .input {
      color: #0f0;
    }
    #signature {
      position: fixed;
      bottom: 5px;
      right: 10px;
      color: #0f0;
      font-family: monospace;
      font-size: 14px;
      opacity: 0.7;
    }
    .blink {
      display: inline-block;
      width: 10px;
      background: #0f0;
      margin-left: 2px;
      animation: blink 1s step-start 0s infinite;
      vertical-align: bottom;
    }
    @keyframes blink {
      50% { opacity: 0; }
    }
    /* Editor overlay */
    #editor {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #000;
      z-index: 9999;
      flex-direction: column;
    }
    #editor-header {
      color: #0f0;
      font-family: monospace;
      padding: 5px;
      border-bottom: 1px solid #0f0;
    }
    #editor-area {
      width: 100%;
      height: calc(100% - 30px);
      background: #000;
      color: #0f0;
      font-family: monospace;
      border: none;
      resize: none;
      padding: 5px;
      outline: none;
    }
  </style>
</head>
<body>
  <div id="terminal"></div>
  <div id="signature">MKalil</div>

  <div id="editor">
    <div id="editor-header">NANO. Ctrl+S salvar, Ctrl+Q sair.</div>
    <textarea id="editor-area" spellcheck="false"></textarea>
  </div>

  <script>
    (function() {
      const term = document.getElementById('terminal');
      const editorOverlay = document.getElementById('editor');
      const editorArea = document.getElementById('editor-area');

      let currentLine = '';
      let inputSpan = null;
      let loginState = 'login_username';
      let tempUsername = '';
      let currentUser = '';
      let currentPath = '/home/root';
      let currentTTY = 1;
      let isPasswordPrompt = false;
      let poweredOff = false;
      let isInEditor = false;
      let editorFilename = '';
      let historyList = [];
      let skipNextPrompt = false;
      // Pacotes instalados, nano já disponível
      const installedPackages = new Set(['nano']);

      const fileSystem = {
        '/': ['boot','bin','dev','etc','home','lib','media','mnt','opt','proc','root','sbin','srv','sys','tmp','usr','var'],
        '/boot': [],
        '/bin': [],
        '/dev': [],
        '/etc': ['network','hosts'],
        '/etc/network': ['interfaces'],
        '/etc/network/interfaces': [],
        '/etc/hosts': [],
        '/home': ['root'],
        '/home/root': [],
        '/lib': [],
        '/media': [],
        '/mnt': [],
        '/opt': [],
        '/proc': [],
        '/root': [],
        '/sbin': [],
        '/srv': [],
        '/sys': [],
        '/tmp': [],
        '/usr': ['bin','sbin','lib','share'],
        '/usr/bin': [],
        '/usr/sbin': [],
        '/usr/lib': [],
        '/usr/share': [],
        '/var': ['log','tmp'],
        '/var/log': [],
        '/var/tmp': []
      };
      const fileContents = {
        '/etc/network/interfaces': 
`# This file describes the network interfaces available on your system
# and how to activate them. For more information, see interfaces(5).

auto enp0s8
iface enp0s8 inet static
    address 10.3.46.113/24
`,
        '/etc/hosts': 
`127.0.0.1   localhost
127.0.1.1   debian
`
      };
      const dirDesc = {
        boot: 'Arquivos de inicialização do Sistema',
        bin: 'Os binários (programas que o usuário comum pode executar)',
        dev: 'Local onde o sistema reconhece os dispositivos (HW)',
        etc: 'Local onde encontramos os arquivos de configuração',
        home: 'Local onde encontramos os diretórios pessoais dos usuários comuns',
        lib: 'Local onde encontramos as bibliotecas compartilhadas',
        media: 'Local onde montamos os dispositivos de mídia removível',
        mnt: 'Local onde montamos os compartilhamentos de rede',
        opt: 'Local onde instalamos programas opcionais (interface gráfica)',
        proc: 'Pseudo Sistema de Arquivos virtual, onde encontramos informações sobre processamento',
        root: 'Local onde encontramos os arquivos pessoais do root',
        sbin: 'Os binários do super usuário (somente o root pode executar)',
        srv: 'Local onde encontramos arquivos referentes aos serviços',
        sys: 'Pseudo Sistema de arquivos virtual que contém informações vindas do /dev e do /proc',
        tmp: 'Local onde encontramos os arquivos temporários',
        usr: 'Local onde encontramos de uso do usuário (manuais, ajuda, int. Gráfica – dados estáticos)',
        var: 'Local onde encontramos os dados variáveis (logs, emails, banco de dados)',
        network: 'Subdiretório de configuração de rede'
      };

      function print(text) {
        term.innerHTML += text;
        term.scrollTop = term.scrollHeight;
      }
      function println(text = '') {
        print(text + '\n');
      }
      function createInput() {
        inputSpan = document.createElement('span');
        inputSpan.className = 'input';
        term.appendChild(inputSpan);
        const blink = document.createElement('span');
        blink.className = 'blink';
        term.appendChild(blink);
        term.scrollTop = term.scrollHeight;
      }
      function removeInput() {
        if (inputSpan) {
          const next = inputSpan.nextSibling;
          if (next && next.className === 'blink') {
            term.removeChild(next);
          }
          inputSpan = null;
        }
      }

      function showLoginPrompt() {
        println('Debian GNU/Linux 11 debian tty' + currentTTY);
        println('');
        print('debian login: ');
        createInput();
        isPasswordPrompt = false;
        loginState = 'login_username';
      }

      function newPrompt() {
        print(currentUser + '@debian:' + currentPath + (currentUser === 'root' ? '#' : '$') + ' ');
        createInput();
        isPasswordPrompt = false;
      }

      function resolvePath(path) {
        if (path.startsWith('/')) {
          if (path.endsWith('/') && path !== '/') path = path.slice(0, -1);
          return path === '' ? '/' : path;
        } else if (path === '..') {
          if (currentPath !== '/') {
            const parts = currentPath.split('/');
            parts.pop();
            return parts.join('/') || '/';
          }
          return currentPath;
        } else if (path === '.') {
          return currentPath;
        } else {
          const candidate = (currentPath === '/' ? '/' + path : currentPath + '/' + path);
          return candidate.replace(/\/+/g, '/');
        }
      }

      function pathExists(p) {
        if (fileSystem[p] !== undefined) return 'dir';
        if (fileContents[p] !== undefined) return 'file';
        return false;
      }

      function ensureParentDir(p) {
        const idx = p.lastIndexOf('/');
        const parent = idx > 0 ? p.slice(0, idx) : '/';
        const name = p.slice(idx + 1);
        if (fileSystem[parent] && !fileSystem[parent].includes(name)) {
          fileSystem[parent].push(name);
        }
      }

      function openEditor(filename) {
        isInEditor = true;
        removeInput();
        const fullPath = resolvePath(filename);
        editorFilename = fullPath;
        editorArea.value = fileContents[fullPath] || '';
        editorOverlay.style.display = 'flex';
        editorArea.focus();
      }

      function saveEditor() {
        const content = editorArea.value;
        fileContents[editorFilename] = content;
        ensureParentDir(editorFilename);
        const numLines = content.split('\n').length;
        exitEditor();
        println(`[ Wrote ${numLines} lines to ${editorFilename} ]`);
        setTimeout(newPrompt, 100);
      }

      function exitEditor() {
        isInEditor = false;
        editorOverlay.style.display = 'none';
        editorArea.blur();
      }

      function simulateInstall(pkg) {
        skipNextPrompt = true;
        println('Reading package lists... Done');
        println('Building dependency tree... Done');
        println('Reading state information... Done');
        println(`The following NEW packages will be installed:`);
        println(`  ${pkg}`);
        println('0 upgraded, 1 newly installed, 0 to remove and 0 not upgraded.');
        println('Need to get 1,234 kB of archives.');
        println('After this operation, 4,567 kB of additional disk space will be used.');
        println('Do you want to continue? [Y/n] ');
        // Espera Enter do usuário
        let buffer = '';
        const handleKey = function(e) {
          if (e.key === 'Enter') {
            e.preventDefault();
            document.removeEventListener('keydown', handleKey);
            buffer = '';
            println('');
            // Simula o progresso de download e instalação
            const steps = [
              `Get:1 http://ftp.debian.org/debian bookworm/main amd64 ${pkg} amd64 1.0.0 [1,234 kB]`,
              'Fetched 1,234 kB in 1s (1,234 kB/s)',
              `Selecting previously unselected package ${pkg}.`,
              '(Reading database ... 123456 files and directories currently installed.)',
              `Preparing to unpack .../${pkg}_1.0.0_amd64.deb ...`,
              `Unpacking ${pkg} (1.0.0) ...`,
              `Setting up ${pkg} (1.0.0) ...`,
              'Processing triggers for man-db (2.10.2-1) ...'
            ];
            let i = 0;
            function printStep() {
              if (i < steps.length) {
                println(steps[i]);
                i++;
                setTimeout(printStep, 500);
              } else {
                installedPackages.add(pkg);
                skipNextPrompt = false;
                setTimeout(newPrompt, 100);
              }
            }
            printStep();
          } else if (e.key.length === 1) {
            e.preventDefault();
            buffer += e.key;
          }
        };
        document.addEventListener('keydown', handleKey);
      }

      function processCommand(cmd) {
        const args = cmd.trim().split(/\s+/);
        const command = args[0];
        switch(command) {
          case 'whoami':
            println(currentUser);
            break;

          case 'tty':
            println('/dev/tty' + currentTTY);
            break;

          case 'pwd':
            println(currentPath);
            break;

          case 'clear':
            term.innerHTML = '';
            return;

          case 'ls': {
              let target = currentPath;
              let long = false;
              let human = false;
              for (let i = 1; i < args.length; i++) {
                if (args[i] === '-l') long = true;
                if (args[i] === '-h') human = true;
                if (!args[i].startsWith('-')) target = resolvePath(args[i]);
              }
              if (long && target === '/') {
                fileSystem['/'].forEach(name => {
                  const type = 'd';
                  const desc = dirDesc[name] ? '  # ' + dirDesc[name] : '';
                  println(type + 'rwxr-xr-x 2 root root 4.0K Jan  1 00:00 ' + name + desc);
                });
              } else if (fileSystem[target]) {
                if (long) {
                  fileSystem[target].forEach(name => {
                    const full = target === '/' ? '/' + name : target + '/' + name;
                    const isDir = fileSystem[full] !== undefined;
                    const type = isDir ? 'd' : '-';
                    const size = isDir ? '4.0K' : '1.0K';
                    const desc = isDir && dirDesc[name] ? '  # ' + dirDesc[name] : '';
                    println(type + (isDir ? 'rwxr-xr-x' : '-rw-r--r--') + ' 1 root root ' + (human ? size : '1024') + ' Jan  1 00:00 ' + name + desc);
                  });
                } else {
                  println(fileSystem[target].join('  '));
                }
              } else {
                println(`bash: ls: cannot access '${args[1]}': No such file or directory`);
              }
            }
            break;

          case 'cd': {
              const target = args[1] ? resolvePath(args[1]) : '/home/root';
              if (fileSystem[target]) {
                currentPath = target;
              } else {
                println(`bash: cd: ${args[1]}: No such file or directory`);
              }
            }
            break;

          case 'cat': {
              if (!args[1]) {
                println('bash: cat: missing operand');
              } else {
                const target = resolvePath(args[1]);
                if (fileContents[target] !== undefined) {
                  print(fileContents[target]);
                } else if (fileSystem[target] !== undefined) {
                  println(`bash: cat: ${args[1]}: Is a directory`);
                } else {
                  println(`bash: cat: ${args[1]}: No such file or directory`);
                }
              }
            }
            break;

          case 'touch': {
              if (!args[1]) {
                println('bash: touch: missing file operand');
              } else {
                const full = resolvePath(args[1]);
                if (!fileSystem[full] && fileContents[full] === undefined) {
                  fileContents[full] = '';
                  ensureParentDir(full);
                }
              }
            }
            break;

          case 'mkdir': {
              if (!args[1]) {
                println('bash: mkdir: missing operand');
              } else {
                const full = resolvePath(args[1]);
                if (fileSystem[full] || fileContents[full] !== undefined) {
                  println(`bash: mkdir: cannot create directory '${args[1]}': File exists`);
                } else {
                  fileSystem[full] = [];
                  ensureParentDir(full);
                }
              }
            }
            break;

          case 'rmdir': {
              if (!args[1]) {
                println('bash: rmdir: missing operand');
              } else {
                const full = resolvePath(args[1]);
                if (!fileSystem[full]) {
                  println(`bash: rmdir: failed to remove '${args[1]}': No such file or directory`);
                } else if (fileSystem[full].length > 0) {
                  println(`bash: rmdir: failed to remove '${args[1]}': Directory not empty`);
                } else {
                  delete fileSystem[full];
                  const parent = full.slice(0, full.lastIndexOf('/')) || '/';
                  const name = full.slice(full.lastIndexOf('/') + 1);
                  const idx = fileSystem[parent].indexOf(name);
                  if (idx !== -1) fileSystem[parent].splice(idx, 1);
                }
              }
            }
            break;

          case 'rm': {
              if (args.length < 2) {
                println('bash: rm: missing operand');
              } else if (args[1] === '-r' && args[2]) {
                const full = resolvePath(args[2]);
                function removeRecursive(p) {
                  if (fileSystem[p]) {
                    fileSystem[p].forEach(child => {
                      const childPath = p === '/' ? '/' + child : p + '/' + child;
                      removeRecursive(childPath);
                    });
                    delete fileSystem[p];
                    const parent = p.slice(0, p.lastIndexOf('/')) || '/';
                    const name = p.slice(p.lastIndexOf('/') + 1);
                    const idx = fileSystem[parent].indexOf(name);
                    if (idx !== -1) fileSystem[parent].splice(idx, 1);
                  }
                  if (fileContents[p] !== undefined) {
                    delete fileContents[p];
                    const parent = p.slice(0, p.lastIndexOf('/')) || '/';
                    const name = p.slice(p.lastIndexOf('/') + 1);
                    const idx = fileSystem[parent].indexOf(name);
                    if (idx !== -1) fileSystem[parent].splice(idx, 1);
                  }
                }
                removeRecursive(full);
              } else {
                const full = resolvePath(args[1]);
                if (fileContents[full] !== undefined) {
                  delete fileContents[full];
                  const parent = full.slice(0, full.lastIndexOf('/')) || '/';
                  const name = full.slice(full.lastIndexOf('/') + 1);
                  const idx = fileSystem[parent].indexOf(name);
                  if (idx !== -1) fileSystem[parent].splice(idx, 1);
                } else if (fileSystem[full]) {
                  println(`bash: rm: cannot remove '${args[1]}': Is a directory`);
                } else {
                  println(`bash: rm: cannot remove '${args[1]}': No such file or directory`);
                }
              }
            }
            break;

          case 'echo': {
              if (args.includes('>')) {
                const idx = args.indexOf('>');
                const text = args.slice(1, idx).join(' ');
                const filename = args[idx + 1];
                const full = resolvePath(filename);
                fileContents[full] = text + '\n';
                ensureParentDir(full);
              } else {
                println(args.slice(1).join(' '));
              }
            }
            break;

          case 'chmod':
            if (args.length < 3) println('chmod: missing operand');
            break;

          case 'chown':
            if (args.length < 3) println('chown: missing operand');
            break;

          case 'id':
            println('uid=0(root) gid=0(root) groups=0(root)');
            break;

          case 'uname':
            if (args[1] === '-a') println('Linux debian 5.10.0-8-amd64 #1 SMP Debian 5.10.46-4 (2021-08-03) x86_64 GNU/Linux');
            else println('Linux');
            break;

          case 'hostname':
            println('debian');
            break;

          case 'uptime':
            println(' 07:34:25 up 1 day,  1:23,  1 user,  load average: 0.00, 0.01, 0.05');
            break;

          case 'who':
            println('root     pts/1        Jun 01 00:00');
            break;

          case 'users':
            println('root');
            break;

          case 'history':
            historyList.forEach((item, idx) => println(`  ${idx + 1}  ${item}`));
            break;

          case 'lsblk':
            println('NAME   MAJ:MIN RM   SIZE RO TYPE MOUNTPOINT');
            println('sda      8:0    0    30G  0 disk');
            println('└─sda1   8:1    0    30G  0 part /');
            println('sr0     11:0    1   1024M  0 rom ');
            break;

          case 'mount':
            println('/dev/sda1 on / type ext4 (rw,relatime,errors=remount-ro)');
            println('tmpfs on /run type tmpfs (rw,nosuid,noexec,relatime,size=1024000k)');
            break;

          case 'df':
            if (args[1] === '-h') {
              println('Filesystem      Size  Used Avail Use% Mounted on');
              println('/dev/sda1        29G  1.2G   27G   5% /');
              println('tmpfs           1.0G     0  1.0G   0% /run');
            } else {
              println('Filesystem     1K-blocks    Used Available Use% Mounted on');
              println('/dev/sda1       30429504 1024000  27405504   4% /');
              println('tmpfs            1024000       0   1024000   0% /run');
            }
            break;

          case 'free':
            if (args[1] === '-h') {
              println('              total        used        free      shared  buff/cache   available');
              println('Mem:           1.9G        512M       1.0G        12M        345M       1.2G');
              println('Swap:          1.0G          0B       1.0G');
            } else {
              println('              total        used        free      shared  buff/cache   available');
              println('Mem:         1997312     524288    1048576      12288     353824    1254400');
              println('Swap:        1048576          0    1048576');
            }
            break;

          case 'date':
            println('Sun Jun  1 00:00:00 UTC 2025');
            break;

          case 'cal':
            println('     June 2025');
            println('Su Mo Tu We Th Fr Sa');
            println(' 1  2  3  4  5  6  7');
            println(' 8  9 10 11 12 13 14');
            println('15 16 17 18 19 20 21');
            println('22 23 24 25 26 27 28');
            println('29 30');
            break;

          case 'ip':
            if (args[1] === 'address' && args[2] === 'show') {
              println('1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN qlen 1000');
              println('    inet 127.0.0.1/8 scope host lo');
              println('');
              println('2: enp0s3: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP qlen 1000');
              println('    inet 10.0.2.15/24 brd 10.0.2.255 scope global enp0s3');
              println('    link/ether 08:00:27:53:8b:1c');
              println('');
              println('3: enp0s8: <BROADCAST,MULTICAST> mtu 1500 qdisc noop state DOWN qlen 1000');
              println('    link/ether 08:00:27:2d:4e:6a');
            } else if (args[1] === 'a' && args[2] === 's' && args[3] === 'enp0s8') {
              println('3: enp0s8: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP qlen 1000');
              println('    inet 10.3.46.113/24 brd 10.3.46.255 scope global enp0s8');
              println('    link/ether 08:00:27:2d:4e:6a');
            } else {
              println(`bash: ip: comando não encontrado ou parâmetros incorretos`);
            }
            break;

          case 'ifconfig':
            println('enp0s3: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500');
            println('    inet 10.0.2.15  netmask 255.255.255.0  broadcast 10.0.2.255');
            println('    inet6 fe80::a00:27ff:fe53:8b1c  prefixlen 64  scopeid 0x20<link>');
            println('    ether 08:00:27:53:8b:1c  txqueuelen 1000  (Ethernet)');
            println('    RX packets 12345  bytes 9876543 (9.8 MB)');
            println('    RX errors 0  dropped 0  overruns 0  frame 0');
            println('    TX packets 12345  bytes 9876543 (9.8 MB)');
            println('    TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0');
            println('');
            println('lo: flags=73<UP,LOOPBACK,RUNNING>  mtu 65536');
            println('    inet 127.0.0.1  netmask 255.0.0.0');
            println('    inet6 ::1  prefixlen 128  scopeid 0x10<host>');
            println('    loop  txqueuelen 1000  (Local Loopback)');
            println('    RX packets 1234  bytes 123456 (123.4 KB)');
            println('    RX errors 0  dropped 0  overruns 0  frame 0');
            println('    TX packets 1234  bytes 123456 (123.4 KB)');
            println('    TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0');
            break;

          case 'route':
            println('Kernel IP routing table');
            println('Destination     Gateway         Genmask         Flags Metric Ref Use Iface');
            println('default         10.0.2.2        0.0.0.0         UG    1024   0   0 enp0s3');
            println('10.0.2.0        *               255.255.255.0   U     0      0   0 enp0s3');
            break;

          case 'ping':
            if (!args[1]) println('Usage: ping <host>');
            else {
              println(`PING ${args[1]} (8.8.8.8) 56(84) bytes of data.`);
              println(`64 bytes from 8.8.8.8: icmp_seq=1 ttl=117 time=10.1 ms`);
              println(`64 bytes from 8.8.8.8: icmp_seq=2 ttl=117 time=10.0 ms`);
              println(`--- ${args[1]} ping statistics ---`);
              println(`2 packets transmitted, 2 received, 0% packet loss, time 1001ms`);
            }
            break;

          case 'traceroute':
            if (!args[1]) println('Usage: traceroute <host>');
            else {
              println(`traceroute to ${args[1]} (8.8.8.8), 30 hops max, 60 byte packets`);
              println(` 1  10.0.2.2  0.123 ms  0.090 ms  0.076 ms`);
              println(` 2  192.168.1.1  1.234 ms  1.102 ms  1.001 ms`);
              println(` 3  72.14.204.112  12.345 ms  11.234 ms  11.001 ms`);
            }
            break;

          case 'dhclient':
            if (args[1] === '-v' && args[2] === 'enp0s8') {
              println('DHCPDISCOVER on enp0s8 to 255.255.255.255 port 67 interval 3');
              println('DHCPREQUEST on enp0s8 to 255.255.255.255 port 67');
              println('DHCPOFFER from 10.0.2.2');
              println('DHCPACK from 10.0.2.2');
              println('bound to 10.3.46.113 -- renewal in 3591 seconds.');
            } else println('bash: dhclient: comando não encontrado ou parâmetros incorretos');
            break;

          case 'apt':
          case 'apt-get':
            if (args[1] === 'update') {
              println('Hit:1 http://ftp.debian.org/debian bookworm InRelease');
              println('Reading package lists... Done');
            } else if (args[1] === 'install' && args[2]) {
              const pkg = args[2];
              if (!installedPackages.has(pkg)) {
                simulateInstall(pkg);
              } else {
                println(`${pkg} já está instalado.`);
              }
            } else if (args[1] === 'upgrade') {
              println('Reading package lists... Done');
              println('Building dependency tree... Done');
              println('Reading state information... Done');
              println('0 upgraded, 0 newly installed, 0 to remove and 0 not upgraded.');
            } else println(`bash: ${command}: comando não encontrado ou parâmetros incorretos`);
            break;

          case 'dpkg':
            if (args[1] === '-l') {
              println('Desired=Unknown/Install/Remove/Purge/Hold');
              println('| Status=Not/Inst/Conf-files/Unpacked/halF-conf/Half-inst/trig-aWait/Trig-pend');
              println('|/ Err?=(none)/Reinst-required (Status,Err: uppercase=bad)');
              println('||/ Name           Version        Architecture Description');
              println('+++-==============-==============-============-=================================');
              println('ii  vim            2:8.2.2434-3   amd64        Vi IMproved - enhanced vi editor');
              println('ii  nano           5.9-1          amd64        small, friendly text editor inspiration of Pico');
            } else println(`bash: dpkg: comando não encontrado ou parâmetros incorretos`);
            break;

          case 'vim':
          case 'vi':
            if (!args[1]) println('vim: no file specified');
            else if (installedPackages.has('vim')) openEditor(args[1]);
            else println('bash: vim: command not found');
            break;

          case 'nano':
            if (!args[1]) println('nano: no file specified');
            else if (installedPackages.has('nano')) openEditor(args[1]);
            else println('bash: nano: command not found');
            break;

          case 'service':
            if (args.length < 2) println('Usage: service <name> <action>');
            else println(`${args[1]}: unrecognized service`);
            break;

          case 'systemctl':
            if (args[1] === 'status' && args[2]) println(`Unit ${args[2]}.service could not be found.`);
            else println(`bash: systemctl: comando não encontrado ou parâmetros incorretos`);
            break;

          case 'useradd':
          case 'adduser':
            if (!args[1]) println('Usage: useradd <username>');
            else println(`Usuário '${args[1]}' criado.`);
            break;

          case 'passwd':
            if (!args[1]) println('Usage: passwd <username>');
            else {
              println(`Alterando senha para '${args[1]}':`);
              println('(senha alterada)');
            }
            break;

          case 'wget':
            if (!args[1]) println('Usage: wget <url>');
            else {
              println(`--2025-06-01 00:00:00--  ${args[1]}`);
              println(`Resolving ${args[1]}... 93.184.216.34`);
              println(`Connecting to ${args[1]}|93.184.216.34|:80... connected.`);
              println('HTTP request sent, awaiting response... 200 OK');
              println('Length: 10234 (10K) [text/html]');
              println(`Saving to: '${args[1].split('/').pop()}'`);
              println('10K downloaded, 10.0 KB/s');
            }
            break;

          case 'curl':
            if (!args[1]) println('Usage: curl <url>');
            else println(`<html>Response from ${args[1]}</html>`);
            break;

          case 'tar':
            println('tar: option requires an argument -- f');
            break;

          case 'gzip':
            println('Usage: gzip [-dfkhLnNtvV19] [-S suffix] [file...]');
            break;

          case 'unzip':
            println('Archive:  archive.zip');
            println('  inflating: file1.txt');
            println('  inflating: file2.txt');
            break;

          case 'git':
            if (args[1] === 'clone' && args[2]) {
              println(`Cloning into '${args[2].split('/').pop().replace('.git','')}'...`);
              println('remote: Enumerating objects: 10, done.');
              println('remote: Counting objects: 100% (10/10), done.');
              println('remote: Compressing objects: 100% (5/5), done.');
              println('Receiving objects: 100% (10/10), 2.34 KiB | 2.34 MiB/s, done.');
            } else println('git: command not found');
            break;

          case 'top':
            println('top - 00:00:00 up 1 day,  1:23,  1 user,  load average: 0.00, 0.01, 0.05');
            println('Tasks:   2 total,   0 running,   2 sleeping,   0 stopped,   0 zombie');
            println('%Cpu(s):  0.3 us,  0.1 sy,  0.0 ni, 99.5 id,  0.0 wa,  0.0 hi,  0.1 si,  0.0 st');
            println('KiB Mem :   2048000 total,    512000 free,    102400 used,   1433600 buff/cache');
            println('KiB Swap:   1024000 total,   1024000 free,         0 used.   1830400 avail Mem');
            println('  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND');
            println(' 1234 root      20   0   123456   1234    800 S   0.0  0.1   0:00.01 bash');
            break;

          case 'ps':
            println('  PID TTY          TIME CMD');
            println(' 1234 pts/1    00:00:00 bash');
            println(' 1235 pts/1    00:00:00 ps');
            break;

          case 'df':
            if (args[1] === '-h') {
              println('Filesystem      Size  Used Avail Use% Mounted on');
              println('/dev/sda1        29G  1.2G   27G   5% /');
              println('tmpfs           1.0G     0  1.0G   0% /run');
            } else {
              println('Filesystem     1K-blocks    Used Available Use% Mounted on');
              println('/dev/sda1       30429504 1024000  27405504   4% /');
              println('tmpfs            1024000       0   1024000   0% /run');
            }
            break;

          case 'du':
            const targetPath = args[1] ? resolvePath(args[1]) : '.';
            println(`4\t${targetPath}`);
            break;

          case 'su':
            if (args[1] === '-') {
              if (args[2]) println(`Mudando para usuário ${args[2]}.`);
              else println('Mudando para usuário root.');
            } else println('su: opção inválida ou usuário não especificado.');
            break;

          case 'reboot':
            println('Rebooting...');
            setTimeout(() => { location.reload(); }, 1000);
            break;

          case 'poweroff':
            println('Powering off...');
            poweredOff = true;
            break;

          default:
            println(`bash: ${command}: command not found`);
        }
      }

      document.addEventListener('keydown', function(e) {
        if (isInEditor) {
          if (e.ctrlKey && (e.key === 's' || e.key === 'S')) {
            e.preventDefault();
            saveEditor();
          } else if (e.ctrlKey && (e.key === 'q' || e.key === 'Q')) {
            e.preventDefault();
            exitEditor();
            setTimeout(newPrompt, 100);
          }
          return;
        }
        if (poweredOff) return;

        if (e.altKey && /^F[1-6]$/.test(e.key)) {
          const num = parseInt(e.key.substring(1));
          currentTTY = num;
          term.innerHTML = '';
          println('Switching to /dev/tty' + currentTTY);
          if (loginState === 'login_username') {
            print('debian login: ');
            createInput();
            isPasswordPrompt = false;
          } else if (loginState === 'login_password') {
            print('Password: ');
            createInput();
            isPasswordPrompt = true;
          } else if (loginState === 'shell') {
            newPrompt();
          }
          e.preventDefault();
          return;
        }

        if (!inputSpan) return;

        if (e.key === 'Backspace') {
          e.preventDefault();
          if (currentLine.length > 0) {
            currentLine = currentLine.slice(0, -1);
            inputSpan.textContent = inputSpan.textContent.slice(0, -1);
          }
        } else if (e.key === 'Enter') {
          e.preventDefault();
          removeInput();
          const cmd = currentLine;
          currentLine = '';
          println('');
          if (loginState.startsWith('login')) {
            if (loginState === 'login_username') {
              tempUsername = cmd.trim();
              if (tempUsername === 'root') {
                loginState = 'login_password';
                print('Password: ');
                createInput();
                isPasswordPrompt = true;
              } else {
                println('Login incorreto');
                print('debian login: ');
                createInput();
                isPasswordPrompt = false;
              }
            } else if (loginState === 'login_password') {
              if (tempUsername === 'root' && cmd === 'fiap') {
                currentUser = 'root';
                loginState = 'shell';
                println('');
                newPrompt();
              } else {
                println('Login incorreto');
                loginState = 'login_username';
                print('debian login: ');
                createInput();
                isPasswordPrompt = false;
              }
            }
          } else if (loginState === 'shell') {
            if (cmd.trim()) historyList.push(cmd.trim());
            processCommand(cmd);
            if (!poweredOff && !isInEditor && !skipNextPrompt) {
              setTimeout(newPrompt, 100);
            } else if (skipNextPrompt) {
              skipNextPrompt = false;
            }
          }
        } else if (e.key.length === 1) {
          e.preventDefault();
          currentLine += e.key;
          inputSpan.textContent += isPasswordPrompt ? '*' : e.key;
        } else if (e.key === 'l' && e.ctrlKey) {
          e.preventDefault();
          term.innerHTML = '';
          if (loginState === 'shell') {
            newPrompt();
          }
        }
      });

      showLoginPrompt();
    })();
  </script>
</body>
</html>