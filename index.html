<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Terminal Debian </title>
    <link rel="icon" href="favicon.ico" type="image/x-icon">
    <style>
        :root {
            --bg-color: #0a0b0c;
            --terminal-bg: #000000;
            --terminal-text: #d9d9d9;
            --terminal-prompt: #50fa7b;
            --terminal-success: #50fa7b;
            --terminal-error: #ff5555;
            --glow-color: rgba(80, 250, 123, 0.3);
            --terminal-width: 90vw;
            --terminal-height: 80vh;
            --accent-color: #50fa7b;
        }

        @media (min-width: 992px) {
            :root {
                --terminal-width: 800px;
                --terminal-height: 500px;
            }
        }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            font-family: 'Courier New', monospace;
            color: var(--terminal-text);
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .background {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(circle at 30% 40%, rgba(0, 100, 0, 0.05) 0%, transparent 40%),
                radial-gradient(circle at 70% 60%, rgba(0, 100, 0, 0.05) 0%, transparent 40%);
            z-index: -1;
        }

        .grid {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                linear-gradient(rgba(0, 50, 0, 0.05) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 50, 0, 0.05) 1px, transparent 1px);
            background-size: 20px 20px;
            z-index: -1;
        }

        .container {
            position: relative;
            width: var(--terminal-width);
            margin: 20px auto;
            z-index: 1;
        }

        .terminal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: linear-gradient(to right, #111, #222);
            padding: 5px 10px;
            border-top-left-radius: 6px;
            border-top-right-radius: 6px;
            border: 1px solid #444;
            border-bottom: none;
        }

        .terminal-title {
            font-size: 14px;
            color: #ddd;
        }

        .terminal-controls {
            display: flex;
            gap: 5px;
        }

        .control-btn {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            border: none;
            cursor: pointer;
        }

        .control-btn.close {
            background-color: #ff5f57;
        }

        .control-btn.minimize {
            background-color: #ffbd2e;
        }

        .control-btn.maximize {
            background-color: #28ca41;
        }

        .terminal-window {
            position: relative;
            width: var(--terminal-width);
            height: var(--terminal-height);
            background-color: var(--terminal-bg);
            border-radius: 0 0 6px 6px;
            box-shadow: 0 0 20px var(--glow-color);
            overflow: hidden;
            border: 1px solid #444;
            animation: boot 2s ease-out;
        }

        .terminal {
            width: 100%;
            height: 100%;
            padding: 10px;
            box-sizing: border-box;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.4;
            color: var(--terminal-text);
            background-color: var(--terminal-bg);
        }

        @media (max-width: 768px) {
            .terminal {
                font-size: 12px;
                padding: 5px;
            }
        }

        .terminal-line {
            white-space: pre-wrap;
            word-break: break-all;
            margin: 2px 0;
        }

        .prompt {
            color: var(--terminal-prompt);
        }

        .success {
            color: var(--terminal-success);
        }

        .error {
            color: var(--terminal-error);
        }

        .scan-line {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 2px;
            background-color: rgba(80, 250, 123, 0.1);
            animation: scan 6s linear infinite;
            pointer-events: none;
        }

        .crt-effect {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(rgba(0, 0, 0, 0.1) 50%, rgba(0, 0, 0, 0.15) 50%);
            background-size: 100% 4px;
            pointer-events: none;
        }

        .blinking-cursor {
            display: inline-block;
            width: 8px;
            height: 14px;
            background-color: var(--terminal-text);
            animation: blink 1s infinite;
            vertical-align: middle;
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            background-color: rgba(0, 20, 0, 0.5);
            border-radius: 6px;
            margin-top: 10px;
            box-shadow: 0 0 10px var(--glow-color);
            width: var(--terminal-width);
            box-sizing: border-box;
        }

        @media (max-width: 768px) {
            .controls {
                flex-direction: column;
                gap: 10px;
            }
            
            .tty-selection, .save-controls {
                width: 100%;
                justify-content: center;
            }
        }

        .tty-selection {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .tty-btn {
            background: #111;
            color: var(--accent-color);
            border: 1px solid #3a3a3a;
            border-radius: 4px;
            padding: 5px 10px;
            cursor: pointer;
            font-family: monospace;
            transition: all 0.2s;
        }

        .tty-btn:hover, .tty-btn.active {
            background: #2d2d2d;
            color: var(--accent-color);
            border-color: var(--accent-color);
        }

        .save-controls {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .save-toggle {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 24px;
        }

        .save-toggle input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .save-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #333;
            transition: .4s;
            border-radius: 24px;
        }

        .save-slider:before {
            position: absolute;
            content: "";
            height: 16px;
            width: 16px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked + .save-slider {
            background-color: var(--accent-color);
        }

        input:checked + .save-slider:before {
            transform: translateX(26px);
        }

        .btn {
            background: #111;
            color: var(--accent-color);
            border: 1px solid #3a3a3a;
            border-radius: 4px;
            padding: 5px 10px;
            cursor: pointer;
            font-family: monospace;
            transition: all 0.2s;
        }

        .btn:hover {
            background: #2d2d2d;
            border-color: var(--accent-color);
        }

        .save-label {
            font-size: 12px;
            color: var(--terminal-text);
        }

        .footer {
            position: absolute;
            bottom: 10px;
            text-align: center;
            color: #888;
            font-size: 12px;
            width: 100%;
            z-index: 10;
        }

        .loading {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 100;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            text-align: center;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid rgba(80, 250, 123, 0.2);
            border-radius: 50%;
            border-top: 4px solid var(--accent-color);
            animation: spin 1s linear infinite;
            margin-bottom: 15px;
        }

        .loading-text {
            color: var(--terminal-text);
            font-family: monospace;
            max-width: 80%;
            text-align: center;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        .modal-content {
            background-color: #0a0b0c;
            padding: 20px;
            border-radius: 6px;
            width: 80%;
            max-width: 600px;
            max-height: 80%;
            overflow-y: auto;
            border: 1px solid #444;
            box-shadow: 0 0 20px var(--glow-color);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            border-bottom: 1px solid #333;
            padding-bottom: 10px;
        }

        .modal-title {
            color: var(--terminal-text);
            font-size: 18px;
        }

        .close-modal {
            color: var(--terminal-text);
            background: none;
            border: none;
            font-size: 20px;
            cursor: pointer;
        }

        .history-item {
            padding: 10px;
            margin: 5px 0;
            background-color: #111;
            border-radius: 5px;
            cursor: pointer;
            border: 1px solid #333;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .history-item:hover {
            background-color: #222;
            border-color: var(--accent-color);
        }

        .history-name {
            color: var(--terminal-text);
        }

        .history-date {
            color: #888;
            font-size: 12px;
        }

        .delete-history {
            color: #ff5555;
            background: none;
            border: none;
            cursor: pointer;
            font-size: 16px;
        }

        .no-history {
            color: #888;
            text-align: center;
            padding: 20px;
        }

        #login-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: var(--terminal-bg);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 50;
        }

        .login-box {
            width: 100%;
            max-width: 400px;
            text-align: left;
            font-family: monospace;
            color: var(--terminal-text);
            line-height: 1.5;
        }

        .login-input {
            background: transparent;
            border: none;
            outline: none;
            color: var(--terminal-text);
            font-family: monospace;
            font-size: 14px;
            width: 200px;
        }

        .login-row {
            margin: 5px 0;
        }

        .login-label {
            display: inline-block;
            width: 100px;
        }

        .install-screen {
            background-color: var(--terminal-bg);
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            overflow-y: auto;
            padding: 20px;
            box-sizing: border-box;
            z-index: 60;
            display: none;
        }

        .install-container {
            max-width: 700px;
            margin: 0 auto;
        }

        .install-header {
            text-align: center;
            margin-bottom: 20px;
            color: var(--accent-color);
        }

        .install-step {
            margin-bottom: 30px;
        }

        .install-step-title {
            font-weight: bold;
            margin-bottom: 10px;
            color: var(--accent-color);
        }

        .install-options {
            margin-left: 20px;
        }

        .install-option {
            margin: 5px 0;
            cursor: pointer;
        }

        .install-option:hover {
            color: var(--accent-color);
        }

        .install-option.selected {
            color: var(--accent-color);
        }

        .install-option-radio {
            margin-right: 10px;
        }

        .install-actions {
            margin-top: 20px;
            display: flex;
            justify-content: space-between;
        }

        .install-button {
            background: #111;
            color: var(--terminal-text);
            border: 1px solid #444;
            border-radius: 4px;
            padding: 8px 15px;
            cursor: pointer;
        }

        .install-button:hover {
            background: #222;
            color: var(--accent-color);
            border-color: var(--accent-color);
        }

        .install-progress {
            width: 100%;
            height: 20px;
            background-color: #222;
            margin-top: 20px;
            border-radius: 4px;
            overflow: hidden;
        }

        .install-progress-bar {
            height: 100%;
            width: 0;
            background-color: var(--accent-color);
            transition: width 0.3s;
        }

        .install-partition-table {
            width: 100%;
            border-collapse: collapse;
            margin: 10px 0;
        }

        .install-partition-table th, .install-partition-table td {
            border: 1px solid #333;
            padding: 8px;
            text-align: left;
        }

        .install-partition-table th {
            background-color: #111;
        }

        .install-partition-table tr:hover {
            background-color: #111;
        }

        .install-input {
            background: #111;
            border: 1px solid #333;
            color: var(--terminal-text);
            padding: 5px;
            width: 100%;
            box-sizing: border-box;
            font-family: monospace;
        }

        .editor-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--terminal-bg);
            z-index: 70;
            display: none;
            flex-direction: column;
        }

        .editor-header {
            background: #111;
            padding: 5px 10px;
            color: var(--terminal-text);
            font-size: 14px;
            border-bottom: 1px solid #333;
        }

        .editor-content {
            flex: 1;
            padding: 5px;
            outline: none;
            overflow: auto;
            white-space: pre-wrap;
            font-family: monospace;
            font-size: 14px;
            color: var(--terminal-text);
            background: var(--terminal-bg);
            border: none;
            resize: none;
        }

        .editor-footer {
            background: #111;
            padding: 5px 10px;
            color: #888;
            font-size: 12px;
            border-top: 1px solid #333;
            display: flex;
            justify-content: space-between;
        }

        .context-menu {
            position: absolute;
            display: none;
            background: #222;
            border: 1px solid #444;
            border-radius: 4px;
            padding: 5px 0;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
            z-index: 1000;
        }

        .context-menu-item {
            padding: 5px 15px;
            cursor: pointer;
            color: var(--terminal-text);
            font-size: 14px;
        }

        .context-menu-item:hover {
            background: #333;
            color: var(--accent-color);
        }

        .mobile-keyboard {
            display: none;
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            background: #111;
            padding: 5px;
            box-sizing: border-box;
            z-index: 90;
            border-top: 1px solid #333;
        }

        @media (max-width: 768px) {
            .mobile-keyboard {
                display: block;
            }
            
            .terminal-window {
                height: calc(var(--terminal-height) - 50px);
            }
            
            .footer {
                bottom: 60px;
            }
        }

        .mobile-keyboard-row {
            display: flex;
            justify-content: center;
            margin: 2px 0;
        }

        .mobile-key {
            background: #222;
            color: var(--terminal-text);
            border: 1px solid #444;
            border-radius: 4px;
            padding: 6px;
            margin: 2px;
            min-width: 30px;
            text-align: center;
            cursor: pointer;
            user-select: none;
            font-family: monospace;
        }

        .mobile-key:active {
            background: #333;
            color: var(--accent-color);
        }

        .mobile-key.special {
            background: #333;
            min-width: 50px;
        }

        @keyframes boot {
            0% {
                opacity: 0;
                filter: brightness(2);
            }
            20% {
                opacity: 0.7;
                filter: brightness(2);
            }
            30% {
                opacity: 0.5;
                filter: brightness(1);
            }
            40% {
                opacity: 0.8;
                filter: brightness(1.5);
            }
            50% {
                opacity: 0.6;
                filter: brightness(1);
            }
            100% {
                opacity: 1;
                filter: brightness(1);
            }
        }

        @keyframes scan {
            0% {
                top: 0%;
            }
            100% {
                top: 100%;
            }
        }

        @keyframes blink {
            0%, 49% {
                opacity: 1;
            }
            50%, 100% {
                opacity: 0;
            }
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="background"></div>
    <div class="grid"></div>

    <div class="container">
        <div class="terminal-header">
            <div class="terminal-controls">
                <button class="control-btn close"></button>
                <button class="control-btn minimize"></button>
                <button class="control-btn maximize"></button>
            </div>
            <div class="terminal-title">Terminal Debian MK</div>
            <div></div>
        </div>
        <div class="terminal-window">
            <div class="scan-line"></div>
            <div class="crt-effect"></div>
            <div class="terminal" id="terminal">
                <!-- Conteúdo do terminal será adicionado aqui -->
            </div>
            <div class="loading" id="loading">
                <div class="spinner"></div>
                <div class="loading-text" id="loading-text">Carregando...</div>
            </div>
            
            <div id="login-screen">
                <div class="login-box">
                    <div class="login-row">Debian GNU/Linux 12 (bookworm)</div>
                    <div class="login-row">&nbsp;</div>
                    <div class="login-row">
                        <span class="login-label">login:</span>
                        <input type="text" id="login-username" class="login-input" autofocus>
                    </div>
                    <div class="login-row">
                        <span class="login-label">password:</span>
                        <input type="password" id="login-password" class="login-input">
                    </div>
                </div>
            </div>
            
            <div class="install-screen" id="install-screen">
                <div class="install-container">
                    <div class="install-header">
                        <h2>Instalação do Debian GNU/Linux</h2>
                    </div>
                    
                    <div class="install-step" id="install-step-language">
                        <div class="install-step-title">Selecione o idioma</div>
                        <div class="install-options">
                            <div class="install-option selected"><span class="install-option-radio">●</span> Português (Brasil)</div>
                            <div class="install-option"><span class="install-option-radio">○</span> English</div>
                            <div class="install-option"><span class="install-option-radio">○</span> Español</div>
                        </div>
                    </div>
                    
                    <div class="install-step" id="install-step-location" style="display: none;">
                        <div class="install-step-title">Selecione sua localização</div>
                        <div class="install-options">
                            <div class="install-option selected"><span class="install-option-radio">●</span> Brasil</div>
                            <div class="install-option"><span class="install-option-radio">○</span> Estados Unidos</div>
                            <div class="install-option"><span class="install-option-radio">○</span> Portugal</div>
                        </div>
                    </div>
                    
                    <div class="install-step" id="install-step-keyboard" style="display: none;">
                        <div class="install-step-title">Configure o teclado</div>
                        <div class="install-options">
                            <div class="install-option selected"><span class="install-option-radio">●</span> Português (Brasil)</div>
                            <div class="install-option"><span class="install-option-radio">○</span> Inglês (US)</div>
                            <div class="install-option"><span class="install-option-radio">○</span> Português (Portugal)</div>
                        </div>
                    </div>
                    
                    <div class="install-step" id="install-step-hostname" style="display: none;">
                        <div class="install-step-title">Configure o nome da máquina</div>
                        <div class="install-options">
                            <input type="text" class="install-input" id="install-hostname" value="debian" placeholder="Nome da máquina">
                        </div>
                    </div>
                    
                    <div class="install-step" id="install-step-domain" style="display: none;">
                        <div class="install-step-title">Nome de domínio</div>
                        <div class="install-options">
                            <input type="text" class="install-input" id="install-domain" value="" placeholder="Deixe em branco se não tiver">
                        </div>
                    </div>
                    
                    <div class="install-step" id="install-step-root" style="display: none;">
                        <div class="install-step-title">Senha do superusuário (root)</div>
                        <div class="install-options">
                            <div class="login-row">
                                <span class="login-label">Senha:</span>
                                <input type="password" id="install-root-password" class="install-input">
                            </div>
                            <div class="login-row">
                                <span class="login-label">Confirme:</span>
                                <input type="password" id="install-root-password-confirm" class="install-input">
                            </div>
                        </div>
                    </div>
                    
                    <div class="install-step" id="install-step-user" style="display: none;">
                        <div class="install-step-title">Criar um usuário normal</div>
                        <div class="install-options">
                            <div class="login-row">
                                <span class="login-label">Nome completo:</span>
                                <input type="text" id="install-user-fullname" class="install-input">
                            </div>
                            <div class="login-row">
                                <span class="login-label">Usuário:</span>
                                <input type="text" id="install-username" class="install-input">
                            </div>
                            <div class="login-row">
                                <span class="login-label">Senha:</span>
                                <input type="password" id="install-user-password" class="install-input">
                            </div>
                            <div class="login-row">
                                <span class="login-label">Confirme:</span>
                                <input type="password" id="install-user-password-confirm" class="install-input">
                            </div>
                        </div>
                    </div>
                    
                    <div class="install-step" id="install-step-partition" style="display: none;">
                        <div class="install-step-title">Particionar discos</div>
                        <div class="install-options">
                            <div class="install-option selected"><span class="install-option-radio">●</span> Guiado - usar disco inteiro</div>
                            <div class="install-option"><span class="install-option-radio">○</span> Guiado - usar LVM</div>
                            <div class="install-option"><span class="install-option-radio">○</span> Manual</div>
                        </div>
                        
                        <div id="partition-details" style="margin-top: 15px;">
                            <div>Selecione o disco a ser particionado:</div>
                            <div class="install-option selected"><span class="install-option-radio">●</span> SCSI1 (0,0,0) (sda) - 50.0 GB ATA VBOX HARDDISK</div>
                            
                            <div style="margin-top: 15px;">Esquema de particionamento:</div>
                            <table class="install-partition-table">
                                <tr>
                                    <th>Dispositivo</th>
                                    <th>Tamanho</th>
                                    <th>Tipo</th>
                                    <th>Ponto de montagem</th>
                                </tr>
                                <tr>
                                    <td>sda1</td>
                                    <td>500 MB</td>
                                    <td>primária</td>
                                    <td>/boot</td>
                                </tr>
                                <tr>
                                    <td>sda2</td>
                                    <td>4 GB</td>
                                    <td>primária</td>
                                    <td>swap</td>
                                </tr>
                                <tr>
                                    <td>sda3</td>
                                    <td>45.5 GB</td>
                                    <td>primária</td>
                                    <td>/</td>
                                </tr>
                            </table>
                        </div>
                    </div>
                    
                    <div class="install-step" id="install-step-packages" style="display: none;">
                        <div class="install-step-title">Seleção de software</div>
                        <div class="install-options">
                            <div class="install-option"><input type="checkbox" checked> Ambiente de área de trabalho Debian</div>
                            <div class="install-option"><input type="checkbox" checked> ... GNOME</div>
                            <div class="install-option"><input type="checkbox"> ... Xfce</div>
                            <div class="install-option"><input type="checkbox"> ... KDE Plasma</div>
                            <div class="install-option"><input type="checkbox" checked> Servidor web</div>
                            <div class="install-option"><input type="checkbox" checked> Servidor SSH</div>
                            <div class="install-option"><input type="checkbox" checked> Utilitários de sistema padrão</div>
                        </div>
                    </div>
                    
                    <div class="install-step" id="install-step-grub" style="display: none;">
                        <div class="install-step-title">Instalar o carregador de inicialização GRUB</div>
                        <div class="install-options">
                            <div class="install-option selected"><span class="install-option-radio">●</span> Sim, instalar o GRUB no registro mestre de inicialização</div>
                            <div class="install-option"><span class="install-option-radio">○</span> Não</div>
                        </div>
                        
                        <div style="margin-top: 15px;">
                            <div>Dispositivo para instalação do carregador de inicialização:</div>
                            <div class="install-option selected"><span class="install-option-radio">●</span> /dev/sda (ata-VBOX_HARDDISK)</div>
                        </div>
                    </div>
                    
                    <div class="install-step" id="install-step-confirm" style="display: none;">
                        <div class="install-step-title">Finalizar a instalação</div>
                        <div class="install-options">
                            <p>O sistema está pronto para ser instalado. Esta é sua última chance de cancelar as alterações antes que elas sejam gravadas no disco.</p>
                            <p>Após a confirmação, o sistema será instalado. Isso pode levar alguns minutos.</p>
                        </div>
                    </div>
                    
                    <div class="install-step" id="install-step-progress" style="display: none;">
                        <div class="install-step-title">Instalando o sistema</div>
                        <div class="install-progress">
                            <div class="install-progress-bar" id="install-progress-bar"></div>
                        </div>
                        <div id="install-status" style="margin-top: 10px; color: #888;">Iniciando instalação...</div>
                    </div>
                    
                    <div class="install-actions">
                        <button class="install-button" id="install-back" disabled>Voltar</button>
                        <button class="install-button" id="install-next">Avançar</button>
                    </div>
                </div>
            </div>
            
            <div class="editor-container" id="editor-container">
                <div class="editor-header" id="editor-header">
                    Editando: /etc/hostname
                </div>
                <textarea class="editor-content" id="editor-content"></textarea>
                <div class="editor-footer">
                    <div id="editor-status">Pressione Ctrl+O para salvar, Ctrl+X para sair</div>
                    <div id="editor-position">Linha: 1, Coluna: 1</div>
                </div>
            </div>
        </div>
    </div>

    <div class="controls">
        <div class="tty-selection">
            <button class="tty-btn active" data-tty="1">TTY1</button>
            <button class="tty-btn" data-tty="2">TTY2</button>
            <button class="tty-btn" data-tty="3">TTY3</button>
            <button class="tty-btn" data-tty="4">TTY4</button>
            <button class="tty-btn" data-tty="5">TTY5</button>
            <button class="tty-btn" data-tty="6">TTY6</button>
        </div>
        <div class="save-controls">
            <div>
                <label class="save-toggle">
                    <input type="checkbox" id="autoSaveToggle">
                    <span class="save-slider"></span>
                </label>
                <span class="save-label">Auto-salvar</span>
            </div>
            <button class="btn" id="saveBtn">Salvar</button>
            <button class="btn" id="loadBtn">Carregar</button>
            <button class="btn" id="resetBtn">Resetar</button>
        </div>
    </div>

    <div class="mobile-keyboard" id="mobile-keyboard">
        <div class="mobile-keyboard-row">
            <div class="mobile-key">Esc</div>
            <div class="mobile-key">Tab</div>
            <div class="mobile-key">Ctrl</div>
            <div class="mobile-key">Alt</div>
            <div class="mobile-key special">Space</div>
            <div class="mobile-key">|</div>
            <div class="mobile-key">/</div>
            <div class="mobile-key">-</div>
        </div>
        <div class="mobile-keyboard-row">
            <div class="mobile-key">↑</div>
            <div class="mobile-key">↓</div>
            <div class="mobile-key">←</div>
            <div class="mobile-key">→</div>
            <div class="mobile-key special">Backspace</div>
            <div class="mobile-key special">Enter</div>
        </div>
    </div>

    <div class="modal" id="historyModal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title">Histórico de Sessões</div>
                <button class="close-modal" id="closeModal">&times;</button>
            </div>
            <div id="historyList">
                <!-- Os itens do histórico serão adicionados aqui -->
            </div>
        </div>
    </div>

    <div class="context-menu" id="context-menu">
        <div class="context-menu-item" id="context-copy">Copiar</div>
        <div class="context-menu-item" id="context-paste">Colar</div>
    </div>

    <div class="footer">
        &copy; 2025 MKalil - Terminal Debian 
    </div>

    <script>
        const FILESYSTEM_INITIAL = {
            '/': {
                type: 'd',
                permissions: 'drwxr-xr-x',
                owner: 'root',
                group: 'root',
                content: {},
                date: '2025-05-15 08:00'
            }
        };

        const DEFAULT_DIRS = [
            'boot', 'bin', 'dev', 'etc', 'home', 'lib', 'media', 
            'mnt', 'opt', 'proc', 'root', 'sbin', 'srv', 'sys', 
            'tmp', 'usr', 'var'
        ];

        const AVAILABLE_PACKAGES = {
            'adduser': { version: '3.136', size: '456 kB', description: 'add and remove users and groups', installed: false, dependencies: [] },
            'apache2': { version: '2.4.56', size: '8.5MB', description: 'Apache HTTP Server', installed: false, dependencies: ['libapache2-mod-php'] },
            'apt': { version: '2.6.1', size: '4.2MB', description: 'commandline package manager', installed: true, dependencies: [] },
            'apt-utils': { version: '2.6.1', size: '1.1MB', description: 'package management related utility programs', installed: false, dependencies: ['apt'] },
            'bash': { version: '5.2.15', size: '6.4MB', description: 'GNU Bourne Again SHell', installed: true, dependencies: [] },
            'bash-completion': { version: '2.11', size: '1.6MB', description: 'programmable completion for the bash shell', installed: false, dependencies: ['bash'] },
            'bc': { version: '1.07.1', size: '224 kB', description: 'GNU bc arbitrary precision calculator language', installed: false, dependencies: [] },
            'bind9': { version: '9.18.16', size: '14MB', description: 'Internet Domain Name Server', installed: false, dependencies: [] },
            'build-essential': { version: '12.9', size: '8 kB', description: 'Informational list of build-essential packages', installed: false, dependencies: ['gcc', 'g++', 'make'] },
            'bzip2': { version: '1.0.8', size: '112 kB', description: 'high-quality block-sorting file compressor - utilities', installed: false, dependencies: [] },
            'ca-certificates': { version: '20230311', size: '364 kB', description: 'Common CA certificates', installed: true, dependencies: [] },
            'cloud-init': { version: '23.1.2', size: '4.6MB', description: 'initialization and customization tool for cloud instances', installed: false, dependencies: [] },
            'coreutils': { version: '9.1', size: '14MB', description: 'GNU core utilities', installed: true, dependencies: [] },
            'cpio': { version: '2.13', size: '392 kB', description: 'GNU cpio -- a program to manage archives of files', installed: false, dependencies: [] },
            'cron': { version: '3.0', size: '256 kB', description: 'process scheduling daemon', installed: false, dependencies: [] },
            'curl': { version: '7.88.1', size: '1.2MB', description: 'command line tool for transferring data with URL syntax', installed: false, dependencies: [] },
            'dash': { version: '0.5.12', size: '168 kB', description: 'POSIX-compliant shell', installed: true, dependencies: [] },
            'dbus': { version: '1.14.8', size: '1.2MB', description: 'simple interprocess messaging system', installed: true, dependencies: [] },
            'diffutils': { version: '3.8', size: '1.4MB', description: 'File comparison utilities', installed: true, dependencies: [] },
            'dig': { version: '9.18.16', size: '156 kB', description: 'DNS lookup utility', installed: false, dependencies: [] },
            'dnsutils': { version: '9.18.16', size: '240 kB', description: 'Clients provided with BIND', installed: false, dependencies: [] },
            'docker.io': { version: '24.0.5', size: '36MB', description: 'Linux container runtime', installed: false, dependencies: [] },
            'dpkg': { version: '1.21.22', size: '7.2MB', description: 'Debian package management system', installed: true, dependencies: [] },
            'e2fsprogs': { version: '1.47.0', size: '4.8MB', description: 'ext2/ext3/ext4 file system utilities', installed: true, dependencies: [] },
            'efibootmgr': { version: '17', size: '68 kB', description: 'Interact with the EFI Boot Manager', installed: false, dependencies: [] },
            'eject': { version: '2.37.4', size: '48 kB', description: 'ejects CDs and operates CD-Changers under Linux', installed: false, dependencies: [] },
            'ethtool': { version: '6.1', size: '256 kB', description: 'display or change Ethernet device settings', installed: false, dependencies: [] },
            'fdisk': { version: '2.37.4', size: '448 kB', description: 'collection of partitioning utilities', installed: true, dependencies: [] },
            'ffmpeg': { version: '5.1.3', size: '5.6MB', description: 'Tools for transcoding, streaming and playing of multimedia files', installed: false, dependencies: [] },
            'file': { version: '5.44', size: '96 kB', description: 'Recognize the type of data in a file using "magic" numbers', installed: true, dependencies: [] },
            'findutils': { version: '4.9.0', size: '1.9MB', description: 'utilities for finding files--find, xargs', installed: true, dependencies: [] },
            'firefox-esr': { version: '115.6.0', size: '56MB', description: 'Mozilla Firefox web browser - Extended Support Release (ESR)', installed: false, dependencies: [] },
            'firmware-linux-free': { version: '20210315', size: '5.2MB', description: 'Binary firmware for various drivers in the Linux kernel', installed: false, dependencies: [] },
            'fonts-dejavu': { version: '2.37', size: '10MB', description: 'metapackage to pull in fonts-dejavu-core and fonts-dejavu-extra', installed: false, dependencies: [] },
            'g++': { version: '12.3.0', size: '1.7MB', description: 'GNU C++ compiler', installed: false, dependencies: [] },
            'gcc': { version: '12.3.0', size: '5.6MB', description: 'GNU C compiler', installed: false, dependencies: [] },
            'gdisk': { version: '1.0.9', size: '364 kB', description: 'GPT fdisk text-mode partitioning tool', installed: false, dependencies: [] },
            'git': { version: '2.39.2', size: '9.3MB', description: 'fast, scalable, distributed revision control system', installed: false, dependencies: [] },
            'gnupg': { version: '2.2.40', size: '1.8MB', description: 'GNU privacy guard - a free PGP replacement', installed: false, dependencies: [] },
            'gnupg2': { version: '2.2.40', size: '12 kB', description: 'GNU privacy guard - a free PGP replacement (dummy transitional package)', installed: false, dependencies: ['gnupg'] },
            'gparted': { version: '1.5.0', size: '5.2MB', description: 'GNOME partition editor', installed: false, dependencies: [] },
            'gpg': { version: '2.2.40', size: '576 kB', description: 'GNU Privacy Guard -- minimalist public key operations', installed: false, dependencies: [] },
            'grep': { version: '3.8', size: '1.1MB', description: 'GNU grep, egrep and fgrep', installed: true, dependencies: [] },
            'groff': { version: '1.22.4', size: '4.8MB', description: 'GNU troff text-formatting system', installed: false, dependencies: [] },
            'grub-common': { version: '2.06', size: '5.2MB', description: 'GRand Unified Bootloader (common files)', installed: true, dependencies: [] },
            'grub-efi-amd64': { version: '2.06', size: '1.8MB', description: 'GRand Unified Bootloader, version 2 (EFI-AMD64 version)', installed: false, dependencies: ['grub-common'] },
            'grub-pc': { version: '2.06', size: '756 kB', description: 'GRand Unified Bootloader, version 2 (PC/BIOS version)', installed: true, dependencies: ['grub-common'] },
            'gzip': { version: '1.12', size: '248 kB', description: 'GNU compression utilities', installed: true, dependencies: [] },
            'hdparm': { version: '9.65', size: '184 kB', description: 'tune hard disk parameters for high performance', installed: false, dependencies: [] },
            'hostname': { version: '3.23', size: '32 kB', description: 'utility to set/show the host name or domain name', installed: true, dependencies: [] },
            'htop': { version: '3.2.2', size: '312 kB', description: 'interactive processes viewer', installed: false, dependencies: [] },
            'iftop': { version: '1.0', size: '88 kB', description: 'displays bandwidth usage information on an network interface', installed: false, dependencies: [] },
            'init': { version: '1.65', size: '48 kB', description: 'metapackage ensuring an init system is installed', installed: true, dependencies: ['systemd'] },
            'initramfs-tools': { version: '0.142', size: '512 kB', description: 'generic modular initramfs generator (automation)', installed: true, dependencies: [] },
            'iproute2': { version: '6.1.0', size: '1.9MB', description: 'networking and traffic control tools', installed: true, dependencies: [] },
            'iptables': { version: '1.8.9', size: '1.1MB', description: 'administration tools for packet filtering and NAT', installed: false, dependencies: [] },
            'iputils-ping': { version: '3.7', size: '92 kB', description: 'Tools to test the reachability of network hosts', installed: true, dependencies: [] },
            'less': { version: '590', size: '344 kB', description: 'pager program similar to more', installed: true, dependencies: [] },
            'libapache2-mod-php': { version: '8.2.0', size: '3.4MB', description: 'server-side, HTML-embedded scripting language (Apache 2 module)', installed: false, dependencies: ['php'] },
            'locales': { version: '2.36', size: '4.2MB', description: 'GNU C Library: National Language (locale) data [support]', installed: true, dependencies: [] },
            'login': { version: '1.6.4', size: '848 kB', description: 'system login tools', installed: true, dependencies: [] },
            'logrotate': { version: '3.20.1', size: '192 kB', description: 'Log rotation utility', installed: false, dependencies: [] },
            'lsb-release': { version: '12.0', size: '56 kB', description: 'Linux Standard Base version reporting utility', installed: true, dependencies: [] },
            'lsof': { version: '4.95.0', size: '476 kB', description: 'utility to list open files', installed: false, dependencies: [] },
            'lvm2': { version: '2.03.16', size: '1.8MB', description: 'Linux Logical Volume Manager', installed: false, dependencies: [] },
            'make': { version: '4.3', size: '776 kB', description: 'utility for directing compilation', installed: false, dependencies: [] },
            'man-db': { version: '2.11.2', size: '1.7MB', description: 'tools for reading manual pages', installed: true, dependencies: [] },
            'mariadb-server': { version: '10.11.4', size: '26MB', description: 'MariaDB database server', installed: false, dependencies: [] },
            'mc': { version: '4.8.29', size: '2.8MB', description: 'Midnight Commander - a powerful file manager', installed: false, dependencies: [] },
            'mdadm': { version: '4.2', size: '1.1MB', description: 'tool to administer Linux MD arrays (software RAID)', installed: false, dependencies: [] },
            'mlocate': { version: '0.26', size: '168 kB', description: 'quickly find files on the filesystem based on their name', installed: false, dependencies: [] },
            'mount': { version: '2.37.4', size: '392 kB', description: 'tools for mounting and manipulating filesystems', installed: true, dependencies: [] },
            'mtr': { version: '0.95', size: '128 kB', description: 'Full screen ncurses and X11 traceroute tool', installed: false, dependencies: [] },
            'mysql-server': { version: '8.0.32', size: '12.7MB', description: 'MySQL database server (metapackage depending on the latest version)', installed: false, dependencies: [] },
            'nano': { version: '7.2', size: '824 kB', description: 'small, friendly text editor inspired by Pico', installed: true, dependencies: [] },
            'ncdu': { version: '1.18', size: '96 kB', description: 'ncurses disk usage viewer', installed: false, dependencies: [] },
            'net-tools': { version: '2.10', size: '960 kB', description: 'NET-3 networking toolkit', installed: false, dependencies: [] },
            'netcat-openbsd': { version: '1.218', size: '92 kB', description: 'TCP/IP swiss army knife', installed: false, dependencies: [] },
            'netplan.io': { version: '0.106', size: '512 kB', description: 'YAML network configuration abstraction for various backends', installed: false, dependencies: [] },
            'network-manager': { version: '1.42.4', size: '2.8MB', description: 'network management framework (daemon and userspace tools)', installed: false, dependencies: [] },
            'nftables': { version: '1.0.6', size: '476 kB', description: 'Program to control packet filtering rules by Netfilter project', installed: false, dependencies: [] },
            'nginx': { version: '1.22.1', size: '7.8MB', description: 'small, powerful, scalable web/proxy server', installed: false, dependencies: [] },
            'nmap': { version: '7.93', size: '6.2MB', description: 'The Network Mapper', installed: false, dependencies: [] },
            'nodejs': { version: '18.13.0', size: '11.2MB', description: 'evented I/O for V8 javascript - runtime executable', installed: false, dependencies: [] },
            'ntp': { version: '4.2.8', size: '2.4MB', description: 'Network Time Protocol daemon and utility programs', installed: false, dependencies: [] },
            'openssh-client': { version: '9.2p1', size: '1.8MB', description: 'secure shell (SSH) client, for secure access to remote machines', installed: true, dependencies: [] },
            'openssh-server': { version: '9.2p1', size: '2.8MB', description: 'secure shell (SSH) server, for secure access from remote machines', installed: false, dependencies: ['openssh-client'] },
            'openssl': { version: '3.0.9', size: '1.6MB', description: 'Secure Sockets Layer toolkit - cryptographic utility', installed: true, dependencies: [] },
            'parted': { version: '3.5', size: '592 kB', description: 'disk partition manipulator', installed: false, dependencies: [] },
            'passwd': { version: '1.6.4', size: '1.3MB', description: 'change and administer password and group data', installed: true, dependencies: [] },
            'pciutils': { version: '3.9.0', size: '432 kB', description: 'PCI utilities', installed: false, dependencies: [] },
            'perl': { version: '5.36.0', size: '12MB', description: 'Larry Wall\'s Practical Extraction and Report Language', installed: true, dependencies: [] },
            'php': { version: '8.2.0', size: '5.2MB', description: 'server-side, HTML-embedded scripting language', installed: false, dependencies: [] },
            'php-mysql': { version: '8.2.0', size: '548 kB', description: 'MySQL module for PHP', installed: false, dependencies: ['php'] },
            'procps': { version: '4.0.3', size: '1.1MB', description: '/proc file system utilities', installed: true, dependencies: [] },
            'psmisc': { version: '23.6', size: '456 kB', description: 'utilities that use the proc file system', installed: false, dependencies: [] },
            'python3': { version: '3.11.2', size: '4.6MB', description: 'interactive high-level object-oriented language', installed: true, dependencies: [] },
            'python3-pip': { version: '23.0.1', size: '1.9MB', description: 'Python package installer', installed: false, dependencies: ['python3'] },
            'qemu-guest-agent': { version: '7.2', size: '1.7MB', description: 'Guest-side qemu-system agent', installed: false, dependencies: [] },
            'rsync': { version: '3.2.7', size: '756 kB', description: 'fast, versatile, remote (and local) file-copying tool', installed: false, dependencies: [] },
            'rsyslog': { version: '8.2212.0', size: '1.6MB', description: 'reliable system and kernel logging daemon', installed: true, dependencies: [] },
            'screen': { version: '4.9.0', size: '1.1MB', description: 'terminal multiplexer with VT100/ANSI terminal emulation', installed: false, dependencies: [] },
            'sed': { version: '4.9', size: '828 kB', description: 'GNU stream editor for filtering/transforming text', installed: true, dependencies: [] },
            'smartmontools': { version: '7.3', size: '1.4MB', description: 'control and monitor storage systems using S.M.A.R.T.', installed: false, dependencies: [] },
            'snmp': { version: '5.9.3', size: '1.9MB', description: 'SNMP (Simple Network Management Protocol) applications', installed: false, dependencies: [] },
            'software-properties-common': { version: '0.99.27', size: '340 kB', description: 'manage the repositories that you install software from', installed: false, dependencies: [] },
            'ssh': { version: '9.2p1', size: '12 kB', description: 'secure shell client and server (metapackage)', installed: false, dependencies: ['openssh-client', 'openssh-server'] },
            'sudo': { version: '1.9.13', size: '1.7MB', description: 'Provide limited super user privileges to specific users', installed: true, dependencies: [] },
            'systemd': { version: '252.12', size: '14MB', description: 'system and service manager', installed: true, dependencies: [] },
            'tar': { version: '1.34', size: '1.8MB', description: 'GNU version of the tar archiving utility', installed: true, dependencies: [] },
            'tcpdump': { version: '4.99.3', size: '824 kB', description: 'command-line network traffic analyzer', installed: false, dependencies: [] },
            'telnet': { version: '0.17', size: '96 kB', description: 'basic telnet client', installed: false, dependencies: [] },
            'tmux': { version: '3.3a', size: '652 kB', description: 'terminal multiplexer', installed: false, dependencies: [] },
            'traceroute': { version: '2.1.2', size: '120 kB', description: 'Traces the route taken by packets over an IPv4/IPv6 network', installed: false, dependencies: [] },
            'tzdata': { version: '2023c', size: '5.8MB', description: 'time zone and daylight-saving time data', installed: true, dependencies: [] },
            'udev': { version: '252.12', size: '6.2MB', description: '/dev/ and hotplug management daemon', installed: true, dependencies: ['systemd'] },
            'ufw': { version: '0.36.1', size: '584 kB', description: 'program for managing a Netfilter firewall', installed: false, dependencies: [] },
            'unattended-upgrades': { version: '2.9.1', size: '576 kB', description: 'automatic installation of security upgrades', installed: false, dependencies: [] },
            'unzip': { version: '6.0', size: '256 kB', description: 'De-archiver for .zip files', installed: false, dependencies: [] },
            'usbutils': { version: '014', size: '468 kB', description: 'Linux USB utilities', installed: false, dependencies: [] },
            'util-linux': { version: '2.37.4', size: '12MB', description: 'miscellaneous system utilities', installed: true, dependencies: [] },
            'vim': { version: '9.0.1378', size: '3.2MB', description: 'Vi IMproved - enhanced vi editor', installed: false, dependencies: [] },
            'vim-tiny': { version: '9.0.1378', size: '824 kB', description: 'Vi IMproved - enhanced vi editor - compact version', installed: true, dependencies: [] },
            'wget': { version: '1.21.3', size: '2.1MB', description: 'retrieves files from the web', installed: false, dependencies: [] },
            'whois': { version: '5.5.16', size: '124 kB', description: 'intelligent WHOIS client', installed: false, dependencies: [] },
            'xfsprogs': { version: '6.1.1', size: '4.2MB', description: 'Utilities for managing the XFS filesystem', installed: false, dependencies: [] },
            'xz-utils': { version: '5.4.1', size: '424 kB', description: 'XZ-format compression utilities', installed: true, dependencies: [] },
            'zip': { version: '3.0', size: '304 kB', description: 'Archiver for .zip files', installed: false, dependencies: [] },
            'zstd': { version: '1.5.4', size: '640 kB', description: 'fast lossless compression algorithm -- CLI tool', installed: false, dependencies: [] }
        };

        const AVAILABLE_COMMANDS = [
            'addgroup', 'adduser', 'apt', 'apt-get', 'arch', 'awk', 'basename', 'bash', 'bc', 'blkid', 'bunzip2', 'bzcat', 'bzip2', 'cal', 'cat', 'cd', 'chgrp', 'chmod', 'chown', 'chroot', 'chvt', 'clear', 'cmp', 'comm', 'cp', 'cpio', 'cron', 'crontab', 'curl', 'cut', 'date', 'dc', 'dd', 'df', 'diff', 'dig', 'dir', 'dmesg', 'dnsdomainname', 'docker', 'dpkg', 'du', 'echo', 'egrep', 'eject', 'env', 'expand', 'expr', 'factor', 'fdisk', 'fgrep', 'file', 'find', 'fmt', 'fold', 'free', 'fsck', 'ftp', 'gcc', 'getopt', 'getty', 'grep', 'groupadd', 'groupdel', 'groupmod', 'groups', 'gzip', 'halt', 'head', 'hexdump', 'hostid', 'hostname', 'htop', 'id', 'ifconfig', 'ifdown', 'ifup', 'init', 'insmod', 'ip', 'iptables', 'journalctl', 'kill', 'killall', 'kmod', 'last', 'ldconfig', 'less', 'link', 'ln', 'locate', 'login', 'ls', 'lsattr', 'lsblk', 'lsmod', 'lsof', 'lspci', 'lsusb', 'man', 'md5sum', 'mkdir', 'mkfifo', 'mknod', 'mkswap', 'modinfo', 'modprobe', 'more', 'mount', 'mv', 'nano', 'nc', 'netstat', 'nice', 'nl', 'nmap', 'nohup', 'nslookup', 'od', 'passwd', 'paste', 'patch', 'pidof', 'ping', 'poweroff', 'pppd', 'printf', 'ps', 'pwd', 'readlink', 'reboot', 'rename', 'renice', 'reset', 'resize', 'rm', 'rmdir', 'rmmod', 'route', 'rpm', 'rsync', 'run-parts', 'scp', 'sed', 'service', 'sftp', 'sh', 'sha1sum', 'sha256sum', 'sha512sum', 'shred', 'shuf', 'shutdown', 'sleep', 'sort', 'split', 'ssh', 'stat', 'strace', 'strings', 'stty', 'su', 'sudo', 'sum', 'swapoff', 'swapon', 'sync', 'systemctl', 'tac', 'tail', 'tar', 'tee', 'test', 'time', 'timeout', 'top', 'touch', 'tr', 'traceroute', 'true', 'tty', 'umount', 'uname', 'unexpand', 'uniq', 'unix2dos', 'unlink', 'unzip', 'uptime', 'useradd', 'userdel', 'usermod', 'users', 'vdir', 'vi', 'vim', 'vmstat', 'w', 'watch', 'wc', 'wget', 'whatis', 'whereis', 'which', 'who', 'whoami', 'write', 'xargs', 'xz', 'zcat', 'zcmp', 'zdiff', 'zgrep', 'zip', 'zmore', 'znew'
        ];

        let filesystem = JSON.parse(JSON.stringify(FILESYSTEM_INITIAL));
        let ttys = {};
        let currentState = {};
        let systemState = {
            installed: false,
            stage: 'boot', // boot, login, install, running
            firstBoot: true,
            needsInstall: true
        };

        const terminal = document.getElementById('terminal');
        const loadingElement = document.getElementById('loading');
        const loadingTextElement = document.getElementById('loading-text');
        const ttyButtons = document.querySelectorAll('.tty-btn');
        const autoSaveToggle = document.getElementById('autoSaveToggle');
        const saveBtn = document.getElementById('saveBtn');
        const loadBtn = document.getElementById('loadBtn');
        const resetBtn = document.getElementById('resetBtn');
        const historyModal = document.getElementById('historyModal');
        const historyList = document.getElementById('historyList');
        const closeModal = document.getElementById('closeModal');
        const loginScreen = document.getElementById('login-screen');
        const loginUsername = document.getElementById('login-username');
        const loginPassword = document.getElementById('login-password');
        const installScreen = document.getElementById('install-screen');
        const editorContainer = document.getElementById('editor-container');
        const editorContent = document.getElementById('editor-content');
        const editorHeader = document.getElementById('editor-header');
        const editorStatus = document.getElementById('editor-status');
        const editorPosition = document.getElementById('editor-position');
        const contextMenu = document.getElementById('context-menu');
        const contextCopy = document.getElementById('context-copy');
        const contextPaste = document.getElementById('context-paste');
        const mobileKeyboard = document.getElementById('mobile-keyboard');
        
        const installBackBtn = document.getElementById('install-back');
        const installNextBtn = document.getElementById('install-next');
        const installProgressBar = document.getElementById('install-progress-bar');
        const installStatus = document.getElementById('install-status');

        let isExecuting = false;
        let currentInput = '';
        let inputPosition = 0;
        let inputHistory = [];
        let historyPosition = -1;
        let autoSave = false;
        let activeEditor = null;
        let currentInstallStep = 0;
        let installData = {
            language: 'Português (Brasil)',
            location: 'Brasil',
            keyboard: 'Português (Brasil)',
            hostname: 'debian',
            domain: '',
            rootPassword: '',
            userFullName: '',
            username: '',
            userPassword: '',
            partitioning: 'guided',
            packages: ['desktop', 'gnome', 'web-server', 'ssh-server', 'standard'],
            installGrub: true,
            grubDevice: '/dev/sda'
        };

        let clipboard = '';
        let selectedText = '';
        let ctrlKeyPressed = false;
        let altKeyPressed = false;

        const installSteps = [
            'install-step-language',
            'install-step-location',
            'install-step-keyboard',
            'install-step-hostname',
            'install-step-domain',
            'install-step-root',
            'install-step-user',
            'install-step-partition',
            'install-step-packages',
            'install-step-grub',
            'install-step-confirm',
            'install-step-progress'
        ];

        window.onload = function() {
            initializeTTYs();
            
            autoSaveToggle.checked = localStorage.getItem('debianTerminalAutoSave') === 'true';
            autoSave = autoSaveToggle.checked;
            
            const needsInstall = !localStorage.getItem('debianTerminalInstalled') || localStorage.getItem('debianTerminalInstalled') === 'false';
            
            if (autoSave && localStorage.getItem('debianTerminalState') && !needsInstall) {
                try {
                    const savedState = JSON.parse(localStorage.getItem('debianTerminalState'));
                    restoreState(savedState);
                    systemState.installed = true;
                    systemState.needsInstall = false;
                } catch (e) {
                    console.error('Erro ao restaurar estado:', e);
                    startSystem();
                }
            } else {
                startSystem();
            }
            
            // Setup mobile keyboard
            setupMobileKeyboard();
            
            document.addEventListener('keydown', function(e) {
                if (e.key === 'Control') ctrlKeyPressed = true;
                if (e.key === 'Alt') altKeyPressed = true;
                
                handleKeyDown(e);
            });
            
            document.addEventListener('keyup', function(e) {
                if (e.key === 'Control') ctrlKeyPressed = false;
                if (e.key === 'Alt') altKeyPressed = false;
            });
            
            document.addEventListener('click', function(e) {
                if (contextMenu.style.display === 'block') {
                    contextMenu.style.display = 'none';
                }
            });
            
            document.addEventListener('contextmenu', function(e) {
                e.preventDefault();
                const selection = window.getSelection();
                if (selection.toString().length > 0) {
                    selectedText = selection.toString();
                    contextMenu.style.left = e.pageX + 'px';
                    contextMenu.style.top = e.pageY + 'px';
                    contextMenu.style.display = 'block';
                }
            });
            
            contextCopy.addEventListener('click', function() {
                navigator.clipboard.writeText(selectedText);
                contextMenu.style.display = 'none';
            });
            
            contextPaste.addEventListener('click', function() {
                navigator.clipboard.readText().then(text => {
                    if (activeEditor) {
                        const cursorPos = editorContent.selectionStart;
                        editorContent.value = editorContent.value.substring(0, cursorPos) + 
                                               text + 
                                               editorContent.value.substring(cursorPos);
                        editorContent.selectionStart = editorContent.selectionEnd = cursorPos + text.length;
                        editorContent.focus();
                    } else {
                        insertText(text);
                    }
                    contextMenu.style.display = 'none';
                });
            });
            
            ttyButtons.forEach(btn => {
                btn.addEventListener('click', function() {
                    switchTTY(parseInt(this.dataset.tty));
                });
            });
            
            autoSaveToggle.addEventListener('change', function() {
                autoSave = this.checked;
                localStorage.setItem('debianTerminalAutoSave', autoSave);
                
                if (autoSave) {
                    saveState();
                }
            });
            
            saveBtn.addEventListener('click', function() {
                const name = prompt('Nome da sessão:', `Sessão ${new Date().toLocaleString()}`);
                if (name) {
                    saveState(name);
                }
            });
            
            loadBtn.addEventListener('click', function() {
                showHistoryModal();
            });
            
            resetBtn.addEventListener('click', function() {
                if (confirm('Tem certeza que deseja resetar o terminal? Todas as alterações não salvas serão perdidas.')) {
                    localStorage.removeItem('debianTerminalInstalled');
                    localStorage.removeItem('debianTerminalState');
                    location.reload();
                }
            });
            
            closeModal.addEventListener('click', function() {
                historyModal.style.display = 'none';
            });
            
            loginUsername.addEventListener('keydown', function(e) {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    loginPassword.focus();
                }
            });
            
            loginPassword.addEventListener('keydown', function(e) {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    handleLogin();
                }
            });
            
            installBackBtn.addEventListener('click', function() {
                if (currentInstallStep > 0) {
                    document.getElementById(installSteps[currentInstallStep]).style.display = 'none';
                    currentInstallStep--;
                    document.getElementById(installSteps[currentInstallStep]).style.display = 'block';
                    
                    installBackBtn.disabled = currentInstallStep === 0;
                    installNextBtn.textContent = 'Avançar';
                }
            });
            
            installNextBtn.addEventListener('click', function() {
                const isValid = validateInstallStep();
                if (!isValid) return;
                
                document.getElementById(installSteps[currentInstallStep]).style.display = 'none';
                currentInstallStep++;
                
                if (currentInstallStep < installSteps.length) {
                    document.getElementById(installSteps[currentInstallStep]).style.display = 'block';
                    installBackBtn.disabled = false;
                    
                    if (currentInstallStep === installSteps.length - 2) {
                        installNextBtn.textContent = 'Instalar';
                    } else if (currentInstallStep === installSteps.length - 1) {
                        installBackBtn.disabled = true;
                        installNextBtn.disabled = true;
                        performInstallation();
                    }
                }
            });
            
            editorContent.addEventListener('keydown', function(e) {
                if (e.ctrlKey && e.key === 'o') {
                    e.preventDefault();
                    saveEditorContent();
                    editorStatus.textContent = 'Arquivo salvo';
                    setTimeout(() => {
                        editorStatus.textContent = 'Pressione Ctrl+O para salvar, Ctrl+X para sair';
                    }, 2000);
                } else if (e.ctrlKey && e.key === 'x') {
                    e.preventDefault();
                    closeEditor();
                }
                
                updateEditorPosition();
            });
            
            editorContent.addEventListener('click', updateEditorPosition);
            editorContent.addEventListener('keyup', updateEditorPosition);
        };

        function setupMobileKeyboard() {
            const mobileKeys = document.querySelectorAll('.mobile-key');
            
            mobileKeys.forEach(key => {
                key.addEventListener('click', function() {
                    const keyText = this.textContent;
                    
                    switch(keyText) {
                        case 'Esc':
                            // Simular Escape
                            document.dispatchEvent(new KeyboardEvent('keydown', { key: 'Escape' }));
                            break;
                        case 'Tab':
                            // Simular Tab
                            document.dispatchEvent(new KeyboardEvent('keydown', { key: 'Tab' }));
                            break;
                        case 'Ctrl':
                            // Toggle Ctrl
                            ctrlKeyPressed = !ctrlKeyPressed;
                            this.style.backgroundColor = ctrlKeyPressed ? '#444' : '#222';
                            break;
                        case 'Alt':
                            // Toggle Alt
                            altKeyPressed = !altKeyPressed;
                            this.style.backgroundColor = altKeyPressed ? '#444' : '#222';
                            break;
                        case 'Space':
                            // Inserir espaço
                            insertText(' ');
                            break;
                        case 'Backspace':
                            // Simular Backspace
                            document.dispatchEvent(new KeyboardEvent('keydown', { key: 'Backspace' }));
                            break;
                        case 'Enter':
                            // Simular Enter
                            document.dispatchEvent(new KeyboardEvent('keydown', { key: 'Enter' }));
                            break;
                        case '↑':
                            // Simular seta para cima
                            document.dispatchEvent(new KeyboardEvent('keydown', { key: 'ArrowUp' }));
                            break;
                        case '↓':
                            // Simular seta para baixo
                            document.dispatchEvent(new KeyboardEvent('keydown', { key: 'ArrowDown' }));
                            break;
                        case '←':
                            // Simular seta para esquerda
                            document.dispatchEvent(new KeyboardEvent('keydown', { key: 'ArrowLeft' }));
                            break;
                        case '→':
                            // Simular seta para direita
                            document.dispatchEvent(new KeyboardEvent('keydown', { key: 'ArrowRight' }));
                            break;
                        default:
                            // Inserir o texto da tecla
                            insertText(keyText);
                            break;
                    }
                });
            });
        }

        function startSystem() {
            initializeFilesystem();
            
            if (systemState.needsInstall) {
                systemState.stage = 'install';
                startInstallation();
            } else {
                systemState.stage = 'boot';
                bootSystem();
            }
        }

        function initializeTTYs() {
            for (let i = 1; i <= 6; i++) {
                ttys[i] = { 
                    history: [], 
                    currentDir: '/', 
                    user: 'root', 
                    hostname: 'debian', 
                    output: [],
                    loginDisplayed: false
                };
            }
            
            currentState = {
                currentTTY: 1,
                networkInterfaces: {
                    lo: {
                        status: 'up',
                        address: '127.0.0.1',
                        netmask: '255.0.0.0'
                    },
                    eth0: {
                        status: 'up',
                        address: '192.168.1.100',
                        netmask: '255.255.255.0',
                        gateway: '192.168.1.1'
                    },
                    eth1: {
                        status: 'down',
                        address: '',
                        netmask: ''
                    }
                },
                users: {
                    'root': {
                        password: 'toor',
                        uid: 0,
                        gid: 0,
                        home: '/root',
                        shell: '/bin/bash',
                        groups: ['root']
                    }
                },
                groups: {
                    'root': { gid: 0, members: ['root'] },
                    'sudo': { gid: 27, members: [] }
                },
                currentUser: '',
                hostname: 'debian',
                uptime: 0,
                bootTime: new Date().getTime(),
                kernel: {
                    version: '6.1.0-11-amd64',
                    status: 'running'
                },
                grub: {
                    status: 'healthy',
                    config: 'default'
                },
                disks: {
                    'sda': {
                        size: '50G',
                        partitions: {
                            'sda1': { 
                                size: '500M', 
                                filesystem: 'ext4', 
                                mountpoint: '/boot', 
                                used: '120M' 
                            },
                            'sda2': { 
                                size: '4G', 
                                filesystem: 'swap', 
                                mountpoint: '[SWAP]', 
                                used: '0' 
                            },
                            'sda3': { 
                                size: '45.5G', 
                                filesystem: 'ext4', 
                                mountpoint: '/', 
                                used: '4.5G' 
                            }
                        }
                    }
                },
                installedPackages: {},
                aptUpdated: false,
                runningProcesses: [],
                services: {
                    'systemd': { status: 'running', enabled: true },
                    'ssh': { status: 'stopped', enabled: false },
                    'apache2': { status: 'stopped', enabled: false },
                    'mysql': { status: 'stopped', enabled: false },
                    'cron': { status: 'running', enabled: true },
                    'rsyslog': { status: 'running', enabled: true }
                }
            };
            
            for (const pkg in AVAILABLE_PACKAGES) {
                if (AVAILABLE_PACKAGES[pkg].installed) {
                    currentState.installedPackages[pkg] = {
                        version: AVAILABLE_PACKAGES[pkg].version,
                        installDate: '2025-06-01'
                    };
                }
            }
        }

        function initializeFilesystem() {
            DEFAULT_DIRS.forEach(dir => {
                filesystem['/'][dir] = {
                    type: 'd',
                    permissions: 'drwxr-xr-x',
                    owner: 'root',
                    group: 'root',
                    content: {},
                    date: '2025-06-01'
                };
            });
            
            filesystem['/']['etc']['passwd'] = {
                type: '-',
                permissions: '-rw-r--r--',
                owner: 'root',
                group: 'root',
                content: 'root:x:0:0:root:/root:/bin/bash',
                date: '2025-06-01'
            };
            
            filesystem['/']['etc']['shadow'] = {
                type: '-',
                permissions: '-rw-r-----',
                owner: 'root',
                group: 'shadow',
                content: 'root:$6$l0HoSBrk$TVL4Z7Oz75Qw/dX1XW5chmTOEVgZfpOyQWtYeGFCDbCTt.e6Jb0bTRJVgvnpkqnf1ffgMgZM2emTqRYP3KQVs/:19508:0:99999:7:::',
                date: '2025-06-01'
            };
            
            filesystem['/']['etc']['hostname'] = {
                type: '-',
                permissions: '-rw-r--r--',
                owner: 'root',
                group: 'root',
                content: 'debian',
                date: '2025-06-01'
            };
            
            filesystem['/']['etc']['apt'] = {
                type: 'd',
                permissions: 'drwxr-xr-x',
                owner: 'root',
                group: 'root',
                content: {},
                date: '2025-06-01'
            };
            
            filesystem['/']['etc']['apt']['sources.list'] = {
                type: '-',
                permissions: '-rw-r--r--',
                owner: 'root',
                group: 'root',
                content: 'deb http://deb.debian.org/debian bookworm main\ndeb http://security.debian.org/debian-security bookworm-security main\ndeb http://deb.debian.org/debian bookworm-updates main',
                date: '2025-06-01'
            };
            
            filesystem['/']['etc']['network'] = {
                type: 'd',
                permissions: 'drwxr-xr-x',
                owner: 'root',
                group: 'root',
                content: {},
                date: '2025-06-01'
            };
            
            filesystem['/']['etc']['network']['interfaces'] = {
                type: '-',
                permissions: '-rw-r--r--',
                owner: 'root',
                group: 'root',
                content: '# This file describes the network interfaces available on your system\n# and how to activate them. For more information, see interfaces(5).\n\nsource /etc/network/interfaces.d/*\n\n# The loopback network interface\nauto lo\niface lo inet loopback\n\n# The primary network interface\nallow-hotplug eth0\niface eth0 inet dhcp',
                date: '2025-06-01'
            };
            
            filesystem['/']['etc']['fstab'] = {
                type: '-',
                permissions: '-rw-r--r--',
                owner: 'root',
                group: 'root',
                content: '# /etc/fstab: static file system information.\n#\n# <file system> <mount point>   <type>  <options>       <dump>  <pass>\nUUID=a1b2c3d4-e5f6-7890-abcd-ef1234567890 /               ext4    errors=remount-ro 0       1\nUUID=b2c3d4e5-f6a1-2345-6789-01abcdef2345 /boot           ext4    defaults        0       2\nUUID=c3d4e5f6-a1b2-3456-7890-12abcdef3456 none            swap    sw              0       0',
                date: '2025-06-01'
            };
            
            filesystem['/']['root'] = {
                type: 'd',
                permissions: 'drwx------',
                owner: 'root',
                group: 'root',
                content: {},
                date: '2025-06-01'
            };
            
            filesystem['/']['root']['.bashrc'] = {
                type: '-',
                permissions: '-rw-r--r--',
                owner: 'root',
                group: 'root',
                content: '# ~/.bashrc: executed by bash(1) for non-login shells.\n\n# If not running interactively, don\'t do anything\ncase $- in\n    *i*) ;;\n      *) return;;\nesac\n\n# don\'t put duplicate lines or lines starting with space in the history.\nHISTCONTROL=ignoreboth\n\n# append to the history file, don\'t overwrite it\nshopt -s histappend\n\n# for setting history length see HISTSIZE and HISTFILESIZE in bash(1)\nHISTSIZE=1000\nHISTFILESIZE=2000\n\n# enable color support of ls and also add handy aliases\nif [ -x /usr/bin/dircolors ]; then\n    test -r ~/.dircolors && eval "$(dircolors -b ~/.dircolors)" || eval "$(dircolors -b)"\n    alias ls=\'ls --color=auto\'\n    alias grep=\'grep --color=auto\'\n    alias fgrep=\'fgrep --color=auto\'\n    alias egrep=\'egrep --color=auto\'\nfi\n\n# colored GCC warnings and errors\nexport GCC_COLORS=\'error=01;31:warning=01;35:note=01;36:caret=01;32:locus=01:quote=01\'\n\n# some more ls aliases\nalias ll=\'ls -l\'\nalias la=\'ls -A\'\nalias l=\'ls -CF\'',
                date: '2025-06-01'
            };
            
            filesystem['/']['home'] = {
                type: 'd',
                permissions: 'drwxr-xr-x',
                owner: 'root',
                group: 'root',
                content: {},
                date: '2025-06-01'
            };
            
            filesystem['/']['etc']['sudoers'] = {
                type: '-',
                permissions: '-r--r-----',
                owner: 'root',
                group: 'root',
                content: 
`# /etc/sudoers
#
# Este arquivo DEVE ser editado com o comando 'visudo'.
#
Defaults	env_reset
Defaults	mail_badpass
Defaults	secure_path="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"

# Usuário root pode executar qualquer coisa em qualquer lugar
root	ALL=(ALL:ALL) ALL

# Permitir membros do grupo sudo a executar qualquer comando
%sudo	ALL=(ALL:ALL) ALL`,
                date: '2025-06-01'
            };
        }

        function bootSystem() {
            terminal.innerHTML = '';
            loginScreen.style.display = 'none';
            
            const bootMessages = [
                { text: 'Booting Debian GNU/Linux...', delay: 500 },
                { text: 'Loading Linux 6.1.0-11-amd64...', delay: 800 },
                { text: 'Loading initial ramdisk...', delay: 1000 },
                { text: '[    0.000000] Linux version 6.1.0-11-amd64 (debian-kernel@lists.debian.org) (gcc-12 (Debian 12.2.0-14) 12.2.0, GNU ld (GNU Binutils for Debian) 2.40)', delay: 300 },
                { text: '[    0.000000] Command line: BOOT_IMAGE=/vmlinuz-6.1.0-11-amd64 root=UUID=a1b2c3d4-e5f6-7890-abcd-ef1234567890 ro quiet', delay: 200 },
                { text: '[    0.000000] x86/fpu: Supporting XSAVE feature 0x001: \'x87 floating point registers\'', delay: 200 },
                { text: '[    0.000000] x86/fpu: Supporting XSAVE feature 0x002: \'SSE registers\'', delay: 200 },
                { text: '[    0.000000] x86/fpu: Supporting XSAVE feature 0x004: \'AVX registers\'', delay: 200 },
                { text: '[    0.000000] x86/fpu: xstate_offset[2]:  576, xstate_sizes[2]:  256', delay: 100 },
                { text: '[    0.000000] x86/fpu: Enabled xstate features 0x7, context size is 832 bytes, using \'standard\' format.', delay: 100 },
                { text: '[    0.204272] Detected 2GHz processor, setting system timer to 1000Hz', delay: 100 },
                { text: '[    0.206431] Console: colour VGA+ 80x25', delay: 100 },
                { text: '[    0.223193] Calibrating delay loop (skipped), value calculated using timer frequency... 4.00 BogoMIPS', delay: 100 },
                { text: '[    0.311024] Checking aperture...', delay: 100 },
                { text: '[    0.492822] Freeing initrd memory: 25296K', delay: 100 },
                { text: '[    0.729354] pci 0000:00:01.1: legacy IDE quirk: reg 0x10: [io  0x01f0-0x01f7]', delay: 100 },
                { text: '[    0.783212] ACPI: Added _OSI(Linux-Dell-Video)', delay: 100 },
                { text: '[    0.788732] ACPI: Added _OSI(Linux-Lenovo-NV-HDMI-Audio)', delay: 100 },
                { text: '[    0.789532] ACPI: Added _OSI(Linux-HPI-Hybrid-Graphics)', delay: 100 },
                { text: '[    0.924912] RAMDISK: gzip image found at block 0', delay: 150 },
                { text: '[    1.045822] input: AT Translated Set 2 keyboard as /devices/platform/i8042/serio0/input/input0', delay: 100 },
                { text: '[    1.209153] EXT4-fs (sda3): mounted filesystem with ordered data mode. Quota mode: none.', delay: 200 },
                { text: '[    1.342212] systemd[1]: Set hostname to <debian>.', delay: 100 },
                { text: '[    1.471253] systemd[1]: Detected virtualization kvm.', delay: 100 },
                { text: '[    1.594823] systemd[1]: Detected architecture x86-64.', delay: 100 },
                { text: '[    1.604922] systemd[1]: Installed transient /etc/machine-id file.', delay: 100 },
                { text: '[    1.779134] systemd[1]: Started Journal Service.', delay: 200 },
                { text: '[    2.022342] systemd[1]: Starting Remount Root and Kernel File Systems...', delay: 100 },
                { text: '[    2.139822] systemd[1]: Starting Load Kernel Modules...', delay: 100 },
                { text: '[    2.295343] systemd[1]: Starting Create Static Device Nodes in /dev...', delay: 100 },
                { text: '[    2.428423] systemd[1]: Started Network Time Synchronization.', delay: 100 },
                { text: '[    2.594927] systemd[1]: Reached target System Time Synchronized.', delay: 150 },
                { text: '[    2.770234] systemd[1]: Started Network Name Resolution.', delay: 150 },
                { text: '[    3.028422] systemd[1]: Starting Login Service...', delay: 300 },
                { text: '[    3.523242] systemd[1]: Started System Logging Service.', delay: 300 },
                { text: '[    3.723242] systemd[1]: Reached target Basic System.', delay: 300 },
                { text: '[    4.093252] systemd[1]: Starting Permit User Sessions...', delay: 300 },
                { text: '[    4.394234] systemd[1]: Started Permit User Sessions.', delay: 300 },
                { text: '[    4.628452] systemd[1]: Started Getty on tty1.', delay: 300 },
                { text: '[    4.823242] systemd[1]: Started Login Service.', delay: 300 },
                { text: '[    5.036344] systemd[1]: Reached target Multi-User System.', delay: 500 }
            ];
            
            let totalDelay = 0;
            
            bootMessages.forEach((msg, index) => {
                totalDelay += msg.delay;
                setTimeout(() => {
                    addOutput(msg.text, 'boot');
                    
                    if (index === bootMessages.length - 1) {
                        setTimeout(() => {
                            systemState.stage = 'login';
                            showLoginScreen();
                        }, 500);
                    }
                }, totalDelay);
            });
        }

        function showLoginScreen() {
            loginScreen.style.display = 'flex';
            loginUsername.value = '';
            loginPassword.value = '';
            loginUsername.focus();
        }

        function handleLogin() {
            const username = loginUsername.value.trim();
            const password = loginPassword.value;
            
            if (!username) {
                return;
            }
            
            if (username in currentState.users) {
                const user = currentState.users[username];
                
                if (user.password === password) {
                    currentState.currentUser = username;
                    ttys[currentState.currentTTY].user = username;
                    ttys[currentState.currentTTY].currentDir = username === 'root' ? '/root' : `/home/${username}`;
                    
                    loginScreen.style.display = 'none';
                    systemState.stage = 'running';
                    
                    addOutput(`Debian GNU/Linux 12 ${currentState.hostname} tty${currentState.currentTTY}`);
                    addOutput('');
                    addOutput(`${currentState.hostname} login: ${username}`);
                    addOutput('Senha: ');
                    addOutput('');
                    addOutput(`Last login: ${new Date().toUTCString()} on tty${currentState.currentTTY}`);
                    addOutput('');
                    
                    renderPrompt();
                } else {
                    loginPassword.value = '';
                    loginPassword.focus();
                    
                    // Adicionar pequeno atraso para simular verificação
                    setTimeout(() => {
                        addOutput(`Debian GNU/Linux 12 ${currentState.hostname} tty${currentState.currentTTY}`);
                        addOutput('');
                        addOutput(`${currentState.hostname} login: ${username}`);
                        addOutput('Senha: ');
                        addOutput('Login incorreto');
                        addOutput('');
                        
                        setTimeout(() => {
                            showLoginScreen();
                        }, 500);
                    }, 800);
                }
            } else {
                loginPassword.value = '';
                loginUsername.focus();
                
                setTimeout(() => {
                    addOutput(`Debian GNU/Linux 12 ${currentState.hostname} tty${currentState.currentTTY}`);
                    addOutput('');
                    addOutput(`${currentState.hostname} login: ${username}`);
                    addOutput('Senha: ');
                    addOutput('Login incorreto');
                    addOutput('');
                    
                    setTimeout(() => {
                        showLoginScreen();
                    }, 500);
                }, 800);
            }
        }

        function startInstallation() {
            installScreen.style.display = 'block';
            loginScreen.style.display = 'none';
            
            currentInstallStep = 0;
            document.getElementById(installSteps[0]).style.display = 'block';
            for (let i = 1; i < installSteps.length; i++) {
                document.getElementById(installSteps[i]).style.display = 'none';
            }
            
            installBackBtn.disabled = true;
            installNextBtn.textContent = 'Avançar';
        }

        function validateInstallStep() {
            switch (installSteps[currentInstallStep]) {
                case 'install-step-hostname':
                    const hostname = document.getElementById('install-hostname').value.trim();
                    if (!hostname) {
                        alert('O nome da máquina não pode estar vazio.');
                        return false;
                    }
                    installData.hostname = hostname;
                    return true;
                    
                case 'install-step-domain':
                    installData.domain = document.getElementById('install-domain').value.trim();
                    return true;
                    
                case 'install-step-root':
                    const rootPass = document.getElementById('install-root-password').value;
                    const rootPassConfirm = document.getElementById('install-root-password-confirm').value;
                    
                    if (!rootPass) {
                        alert('A senha do root não pode estar vazia.');
                        return false;
                    }
                    
                    if (rootPass !== rootPassConfirm) {
                        alert('As senhas não coincidem.');
                        return false;
                    }
                    
                    installData.rootPassword = rootPass;
                    return true;
                    
                case 'install-step-user':
                    const userFullName = document.getElementById('install-user-fullname').value.trim();
                    const username = document.getElementById('install-username').value.trim();
                    const userPass = document.getElementById('install-user-password').value;
                    const userPassConfirm = document.getElementById('install-user-password-confirm').value;
                    
                    if (!userFullName) {
                        alert('O nome completo não pode estar vazio.');
                        return false;
                    }
                    
                    if (!username) {
                        alert('O nome de usuário não pode estar vazio.');
                        return false;
                    }
                    
                    if (!userPass) {
                        alert('A senha do usuário não pode estar vazia.');
                        return false;
                    }
                    
                    if (userPass !== userPassConfirm) {
                        alert('As senhas não coincidem.');
                        return false;
                    }
                    
                    installData.userFullName = userFullName;
                    installData.username = username;
                    installData.userPassword = userPass;
                    return true;
                    
                default:
                    return true;
            }
        }

        function performInstallation() {
            const totalSteps = 12;
            let currentProgress = 0;
            
            const progressMessages = [
                'Verificando requisitos do sistema...',
                'Configurando sistema base...',
                'Particionando discos...',
                'Formatando partições...',
                'Instalando sistema base...',
                'Configurando bootloader GRUB...',
                'Instalando pacotes principais...',
                'Configurando rede...',
                'Configurando contas de usuário...',
                'Configurando serviços...',
                'Finalizando instalação...',
                'Instalação concluída!'
            ];
            
            const updateProgress = () => {
                if (currentProgress < totalSteps) {
                    const percent = Math.round((currentProgress / totalSteps) * 100);
                    installProgressBar.style.width = `${percent}%`;
                    installStatus.textContent = progressMessages[currentProgress];
                    currentProgress++;
                    
                    setTimeout(updateProgress, Math.random() * 1000 + 1000);
                } else {
                    finishInstallation();
                }
            };
            
            updateProgress();
        }

        function finishInstallation() {
            installStatus.textContent = 'Instalação concluída! Reiniciando o sistema...';
            
            systemState.installed = true;
            systemState.needsInstall = false;
            localStorage.setItem('debianTerminalInstalled', 'true');
            
            currentState.hostname = installData.hostname;
            currentState.users['root'].password = installData.rootPassword;
            
            // Garantir que o grupo sudo existe
            if (!currentState.groups['sudo']) {
                currentState.groups['sudo'] = { gid: 27, members: [] };
            }
            
            if (installData.username) {
                currentState.users[installData.username] = {
                    password: installData.userPassword,
                    uid: 1000,
                    gid: 1000,
                    home: `/home/${installData.username}`,
                    shell: '/bin/bash',
                    groups: ['sudo']
                };
                
                currentState.groups['sudo'].members.push(installData.username);
                
                // Criar diretório pessoal do usuário
                filesystem['/']['home'][installData.username] = {
                    type: 'd',
                    permissions: 'drwxr-xr-x',
                    owner: installData.username,
                    group: installData.username,
                    content: {},
                    date: getCurrentDate()
                };
                
                // Copiar arquivos de configuração
                filesystem['/']['home'][installData.username]['.bashrc'] = {
                    type: '-',
                    permissions: '-rw-r--r--',
                    owner: installData.username,
                    group: installData.username,
                    content: filesystem['/']['root']['.bashrc'].content,
                    date: getCurrentDate()
                };
            }
            
            // Atualizar arquivos de configuração
            filesystem['/']['etc']['hostname'].content = installData.hostname;
            
            if (installData.domain) {
                filesystem['/']['etc']['hosts'] = {
                    type: '-',
                    permissions: '-rw-r--r--',
                    owner: 'root',
                    group: 'root',
                    content: `127.0.0.1\tlocalhost\n127.0.1.1\t${installData.hostname}.${installData.domain}\t${installData.hostname}`,
                    date: getCurrentDate()
                };
            } else {
                filesystem['/']['etc']['hosts'] = {
                    type: '-',
                    permissions: '-rw-r--r--',
                    owner: 'root',
                    group: 'root',
                    content: `127.0.0.1\tlocalhost\n127.0.1.1\t${installData.hostname}`,
                    date: getCurrentDate()
                };
            }
            
            // Garantir que o sudo esteja instalado
            currentState.installedPackages['sudo'] = {
                version: '1.9.13',
                installDate: getCurrentDate()
            };
            
            // Configurar o arquivo sudoers
            if (!filesystem['/']['etc']['sudoers']) {
                filesystem['/']['etc']['sudoers'] = {
                    type: '-',
                    permissions: '-r--r-----',
                    owner: 'root',
                    group: 'root',
                    content: 
`# /etc/sudoers
#
# Este arquivo DEVE ser editado com o comando 'visudo'.
#
Defaults	env_reset
Defaults	mail_badpass
Defaults	secure_path="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"

# Usuário root pode executar qualquer coisa em qualquer lugar
root	ALL=(ALL:ALL) ALL

# Permitir membros do grupo sudo a executar qualquer comando
%sudo	ALL=(ALL:ALL) ALL`,
                    date: getCurrentDate()
                };
            }
            
            setTimeout(() => {
                installScreen.style.display = 'none';
                bootSystem();
            }, 3000);
        }

        function renderTerminal() {
            terminal.innerHTML = '';
            
            ttys[currentState.currentTTY].output.forEach(line => {
                const lineElement = document.createElement('div');
                lineElement.className = `terminal-line ${line.type || ''}`;
                lineElement.innerHTML = line.text;
                terminal.appendChild(lineElement);
            });
            
            if (systemState.stage === 'running') {
                renderPrompt();
            }
            
            terminal.scrollTop = terminal.scrollHeight;
        }

        function renderPrompt() {
            // Remover qualquer prompt existente antes de adicionar um novo
            const existingPrompt = terminal.querySelector('.current-prompt');
            if (existingPrompt) {
                existingPrompt.remove();
            }
            
            // Criar nova linha para o prompt
            const promptLine = document.createElement('div');
            promptLine.className = 'terminal-line current-prompt';
            
            const promptText = `${currentState.currentUser}@${currentState.hostname}:${getCurrentDirDisplay()}${currentState.currentUser === 'root' ? '#' : '$'} `;
            
            promptLine.innerHTML = `<span class="prompt">${promptText}</span>`;
            
            const inputSpan = document.createElement('span');
            inputSpan.textContent = currentInput;
            promptLine.appendChild(inputSpan);
            
            const cursor = document.createElement('span');
            cursor.className = 'blinking-cursor';
            promptLine.appendChild(cursor);
            
            terminal.appendChild(promptLine);
        }

        function getCurrentDirDisplay() {
            const currentDir = ttys[currentState.currentTTY].currentDir;
            
            if (currentState.currentUser === 'root' && currentDir === '/root') {
                return '~';
            } else if (currentDir.startsWith('/home/' + currentState.currentUser)) {
                return '~' + currentDir.substring(('/home/' + currentState.currentUser).length);
            }
            
            return currentDir;
        }

        function addOutput(text, type = '') {
            const line = { text, type };
            ttys[currentState.currentTTY].output.push(line);
            
            if (ttys[currentState.currentTTY].output.length > 1000) {
                ttys[currentState.currentTTY].output.shift();
            }
            
            renderTerminal();
            
            if (autoSave) {
                saveState();
            }
        }

        function handleKeyDown(e) {
            if (systemState.stage !== 'running') {
                return;
            }
            
            if (activeEditor) {
                // Estamos no editor, não processar como entrada do terminal
                return;
            }
            
            if (isExecuting) {
                if (e.key === 'c' && e.ctrlKey) {
                    isExecuting = false;
                    addOutput('^C', 'error');
                    renderPrompt();
                }
                return;
            }
            
            if (e.key === 'Enter') {
                const command = currentInput.trim();
                
                if (command) {
                    addOutput(`<span class="prompt">${currentState.currentUser}@${currentState.hostname}:${getCurrentDirDisplay()}${currentState.currentUser === 'root' ? '#' : '$'} </span>${command}`);
                    
                    inputHistory.push(command);
                    if (inputHistory.length > 100) inputHistory.shift();
                    historyPosition = inputHistory.length;
                    
                    executeCommand(command);
                } else {
                    addOutput('');
                    renderPrompt();
                }
                
                currentInput = '';
                inputPosition = 0;
            } else if (e.key === 'Backspace') {
                if (inputPosition > 0) {
                    currentInput = currentInput.substring(0, inputPosition - 1) + currentInput.substring(inputPosition);
                    inputPosition--;
                    renderTerminal();
                }
            } else if (e.key === 'Delete') {
                if (inputPosition < currentInput.length) {
                    currentInput = currentInput.substring(0, inputPosition) + currentInput.substring(inputPosition + 1);
                    renderTerminal();
                }
            } else if (e.key === 'ArrowLeft') {
                if (inputPosition > 0) {
                    inputPosition--;
                    renderTerminal();
                }
            } else if (e.key === 'ArrowRight') {
                if (inputPosition < currentInput.length) {
                    inputPosition++;
                    renderTerminal();
                }
            } else if (e.key === 'ArrowUp') {
                if (historyPosition > 0) {
                    historyPosition--;
                    currentInput = inputHistory[historyPosition];
                    inputPosition = currentInput.length;
                    renderTerminal();
                }
            } else if (e.key === 'ArrowDown') {
                if (historyPosition < inputHistory.length - 1) {
                    historyPosition++;
                    currentInput = inputHistory[historyPosition];
                    inputPosition = currentInput.length;
                    renderTerminal();
                } else if (historyPosition === inputHistory.length - 1) {
                    historyPosition = inputHistory.length;
                    currentInput = '';
                    inputPosition = 0;
                    renderTerminal();
                }
            } else if (e.key === 'Tab') {
                e.preventDefault();
                autocomplete();
            } else if (e.key === 'c' && e.ctrlKey) {
                addOutput('^C');
                currentInput = '';
                inputPosition = 0;
                renderTerminal();
            } else if (e.key === 'l' && e.ctrlKey) {
                ttys[currentState.currentTTY].output = [];
                renderTerminal();
            } else if (e.key.length === 1 && !e.ctrlKey && !e.altKey && !e.metaKey) {
                insertText(e.key);
            }
            
            if (e.altKey && e.key.startsWith('F')) {
                const ttyNum = parseInt(e.key.substring(1));
                if (ttyNum >= 1 && ttyNum <= 6) {
                    switchTTY(ttyNum);
                }
            }
        }

        function insertText(text) {
            currentInput = currentInput.substring(0, inputPosition) + text + currentInput.substring(inputPosition);
            inputPosition += text.length;
            renderTerminal();
        }

        function autocomplete() {
            const args = currentInput.split(' ');
            const lastArg = args[args.length - 1];
            
            if (args.length === 1) {
                // Completar comando
                const matches = AVAILABLE_COMMANDS.filter(cmd => cmd.startsWith(lastArg));
                
                if (matches.length === 1) {
                    currentInput = matches[0];
                    inputPosition = currentInput.length;
                    renderTerminal();
                } else if (matches.length > 1) {
                    addOutput('');
                    
                    // Organizar em colunas
                    const maxCols = Math.floor(terminal.clientWidth / 120) || 1;
                    const colWidth = Math.floor(terminal.clientWidth / maxCols);
                    
                    let row = '';
                    let colCount = 0;
                    
                    matches.forEach(match => {
                        row += match.padEnd(colWidth);
                        colCount++;
                        
                        if (colCount >= maxCols) {
                            addOutput(row);
                            row = '';
                            colCount = 0;
                        }
                    });
                    
                    if (row) {
                        addOutput(row);
                    }
                    
                    addOutput('');
                    renderPrompt();
                }
            } else {
                // Completar caminho
                if (lastArg.startsWith('/') || lastArg.startsWith('./') || lastArg.startsWith('../') || lastArg === '.' || lastArg === '..') {
                    const path = resolvePath(lastArg === '.' || lastArg === '..' ? lastArg + '/' : lastArg);
                    const parentPath = path.substring(0, path.lastIndexOf('/') + 1);
                    const partial = path.substring(path.lastIndexOf('/') + 1);
                    
                    const parentDir = getDirectoryContents(parentPath);
                    
                    if (parentDir && parentDir.type === 'd') {
                        const matches = Object.keys(parentDir.content).filter(name => name.startsWith(partial));
                        
                        if (matches.length === 1) {
                            const isDir = parentDir.content[matches[0]].type === 'd';
                            const replacement = parentPath + matches[0] + (isDir ? '/' : '');
                            const replacementDisplay = lastArg.substring(0, lastArg.lastIndexOf('/') + 1) + matches[0] + (isDir ? '/' : '');
                            
                            args[args.length - 1] = replacementDisplay;
                            currentInput = args.join(' ');
                            inputPosition = currentInput.length;
                            renderTerminal();
                        } else if (matches.length > 1) {
                            addOutput('');
                            
                            // Organizar em colunas
                            const maxCols = Math.floor(terminal.clientWidth / 120) || 1;
                            const colWidth = Math.floor(terminal.clientWidth / maxCols);
                            
                            let row = '';
                            let colCount = 0;
                            
                            matches.forEach(match => {
                                const isDir = parentDir.content[match].type === 'd';
                                row += match + (isDir ? '/' : ' ').padEnd(colWidth - match.length);
                                colCount++;
                                
                                if (colCount >= maxCols) {
                                    addOutput(row);
                                    row = '';
                                    colCount = 0;
                                }
                            });
                            
                            if (row) {
                                addOutput(row);
                            }
                            
                            addOutput('');
                            renderPrompt();
                        }
                    }
                }
            }
        }

        function executeCommand(commandLine) {
            const args = commandLine.split(' ').filter(arg => arg.length > 0);
            const command = args[0].toLowerCase();
            args.shift();
            
            isExecuting = true;
            
            // Tratar redirecionamento
            let outputRedirect = null;
            let outputAppend = false;
            let inputRedirect = null;
            
            for (let i = 0; i < args.length; i++) {
                if (args[i] === '>') {
                    if (i < args.length - 1) {
                        outputRedirect = args[i + 1];
                        args.splice(i, 2);
                        i--;
                    }
                } else if (args[i] === '>>') {
                    if (i < args.length - 1) {
                        outputRedirect = args[i + 1];
                        outputAppend = true;
                        args.splice(i, 2);
                        i--;
                    }
                } else if (args[i] === '<') {
                    if (i < args.length - 1) {
                        inputRedirect = args[i + 1];
                        args.splice(i, 2);
                        i--;
                    }
                }
            }
            
            setTimeout(() => {
                let output = '';
                let errorOutput = '';
                let commandFound = true;
                
                // Obter entrada redirecionada se existir
                let inputContent = '';
                if (inputRedirect) {
                    const inputFile = getDirectoryContents(resolvePath(inputRedirect));
                    if (!inputFile) {
                        errorOutput = `${command}: ${inputRedirect}: Arquivo ou diretório não encontrado`;
                        commandFound = false;
                    } else if (inputFile.type === 'd') {
                        errorOutput = `${command}: ${inputRedirect}: É um diretório`;
                        commandFound = false;
                    } else {
                        inputContent = inputFile.content;
                    }
                }
                
                if (commandFound) {
                    try {
                        switch (command) {
                            case 'ls':
                                output = cmdLs(args);
                                break;
                            case 'cd':
                                output = cmdCd(args);
                                break;
                            case 'pwd':
                                output = cmdPwd();
                                break;
                            case 'cat':
                                output = cmdCat(args, inputContent);
                                break;
                            case 'echo':
                                output = cmdEcho(args);
                                break;
                            case 'whoami':
                                output = currentState.currentUser;
                                break;
                            case 'tty':
                                output = `/dev/tty${currentState.currentTTY}`;
                                break;
                            case 'mkdir':
                                output = cmdMkdir(args);
                                break;
                            case 'rm':
                                output = cmdRm(args);
                                break;
                            case 'cp':
                                output = cmdCp(args);
                                break;
                            case 'mv':
                                output = cmdMv(args);
                                break;
                            case 'touch':
                                output = cmdTouch(args);
                                break;
                            case 'grep':
                                output = cmdGrep(args, inputContent);
                                break;
                            case 'find':
                                output = cmdFind(args);
                                break;
                            case 'clear':
                                ttys[currentState.currentTTY].output = [];
                                renderTerminal();
                                isExecuting = false;
                                return;
                            case 'apt':
                            case 'apt-get':
                                output = cmdApt(args);
                                break;
                            case 'dpkg':
                                output = cmdDpkg(args);
                                break;
                            case 'ip':
                                output = cmdIp(args);
                                break;
                            case 'ifconfig':
                                output = cmdIfconfig(args);
                                break;
                            case 'uname':
                                output = cmdUname(args);
                                break;
                            case 'df':
                                output = cmdDf(args);
                                break;
                            case 'du':
                                output = cmdDu(args);
                                break;
                            case 'ps':
                                output = cmdPs(args);
                                break;
                            case 'top':
                                output = cmdTop();
                                break;
                            case 'kill':
                                output = cmdKill(args);
                                break;
                            case 'free':
                                output = cmdFree(args);
                                break;
                            case 'date':
                                output = new Date().toString();
                                break;
                            case 'man':
                                output = cmdMan(args);
                                break;
                            case 'sudo':
                                output = cmdSudo(args);
                                break;
                            case 'su':
                                cmdSu(args);
                                isExecuting = false;
                                return;
                            case 'passwd':
                                cmdPasswd(args);
                                isExecuting = false;
                                return;
                            case 'nano':
                                cmdNano(args);
                                isExecuting = false;
                                return;
                            case 'vi':
                            case 'vim':
                                cmdVim(args);
                                isExecuting = false;
                                return;
                            case 'fdisk':
                                output = cmdFdisk(args);
                                break;
                            case 'mount':
                                output = cmdMount(args);
                                break;
                            case 'umount':
                                output = cmdUmount(args);
                                break;
                            case 'systemctl':
                                output = cmdSystemctl(args);
                                break;
                            case 'journalctl':
                                output = cmdJournalctl(args);
                                break;
                            case 'reboot':
                                cmdReboot();
                                isExecuting = false;
                                return;
                            case 'poweroff':
                            case 'shutdown':
                                cmdPoweroff();
                                isExecuting = false;
                                return;
                            case 'hostname':
                                output = cmdHostname(args);
                                break;
                            case 'history':
                                output = cmdHistory();
                                break;
                            case 'chmod':
                                output = cmdChmod(args);
                                break;
                            case 'chown':
                                output = cmdChown(args);
                                break;
                            case 'ln':
                                output = cmdLn(args);
                                break;
                            case 'tar':
                                output = cmdTar(args);
                                break;
                            case 'gzip':
                                output = cmdGzip(args);
                                break;
                            case 'gunzip':
                                output = cmdGunzip(args);
                                break;
                            case 'head':
                                output = cmdHead(args, inputContent);
                                break;
                            case 'tail':
                                output = cmdTail(args, inputContent);
                                break;
                            case 'wc':
                                output = cmdWc(args, inputContent);
                                break;
                            case 'sort':
                                output = cmdSort(args, inputContent);
                                break;
                            case 'uniq':
                                output = cmdUniq(args, inputContent);
                                break;
                            case 'wget':
                                output = cmdWget(args);
                                break;
                            case 'curl':
                                output = cmdCurl(args);
                                break;
                            case 'ssh':
                                output = cmdSsh(args);
                                break;
                            case 'scp':
                                output = cmdScp(args);
                                break;
                            case 'exit':
                            case 'logout':
                                cmdLogout();
                                isExecuting = false;
                                return;
                            default:
                                if (AVAILABLE_COMMANDS.includes(command)) {
                                    output = `${command}: comando não disponível nesta simulação`;
                                } else {
                                    errorOutput = `${command}: comando não encontrado`;
                                    commandFound = false;
                                }
                                break;
                        }
                    } catch (e) {
                        errorOutput = `${command}: erro na execução: ${e.message}`;
                        console.error(e);
                    }
                }
                
                // Tratar redirecionamento de saída
                if (outputRedirect && output !== null) {
                    const redirectPath = resolvePath(outputRedirect);
                    const parentDir = getParentDirectory(redirectPath);
                    const fileName = redirectPath.split('/').pop();
                    
                    if (parentDir) {
                        if (outputAppend && parentDir.content[fileName] && parentDir.content[fileName].type === '-') {
                            parentDir.content[fileName].content += '\n' + output;
                        } else {
                            parentDir.content[fileName] = {
                                type: '-',
                                permissions: '-rw-r--r--',
                                owner: currentState.currentUser,
                                group: currentState.currentUser,
                                content: output,
                                date: getCurrentDate()
                            };
                        }
                    } else {
                        errorOutput = `${command}: não foi possível redirecionar: diretório não encontrado`;
                    }
                } else if (output !== null) {
                    // Mostrar saída normal
                    if (output) {
                        output.split('\n').forEach(line => {
                            addOutput(line);
                        });
                    }
                }
                
                if (errorOutput) {
                    addOutput(errorOutput, 'error');
                }
                
                isExecuting = false;
                renderPrompt();
            }, Math.random() * 200 + 50);
        }

        // Implementações dos comandos
        function cmdLs(args) {
            let path = ttys[currentState.currentTTY].currentDir;
            let showHidden = false;
            let longFormat = false;
            let humanReadable = false;
            
            // Processar opções
            args = args.filter(arg => {
                if (arg.startsWith('-')) {
                    if (arg.includes('a')) showHidden = true;
                    if (arg.includes('l')) longFormat = true;
                    if (arg.includes('h')) humanReadable = true;
                    return false;
                }
                return true;
            });
            
            if (args.length > 0) {
                path = resolvePath(args[0]);
            }
            
            const targetDir = getDirectoryContents(path);
            
            if (!targetDir) {
                return `ls: não foi possível acessar '${path}': Arquivo ou diretório não encontrado`;
            }
            
            if (targetDir.type !== 'd') {
                if (longFormat) {
                    const fileName = path.split('/').pop();
                    const size = targetDir.content ? targetDir.content.length : 0;
                    return `${targetDir.permissions} 1 ${targetDir.owner} ${targetDir.group} ${humanReadable ? humanSize(size) : size} ${targetDir.date} ${fileName}`;
                }
                return path.split('/').pop();
            }
            
            const entries = Object.keys(targetDir.content);
            
            if (entries.length === 0) {
                return '';
            }
            
            const filteredEntries = showHidden ? entries : entries.filter(entry => !entry.startsWith('.'));
            
            if (longFormat) {
                let output = [];
                filteredEntries.forEach(entry => {
                    const item = targetDir.content[entry];
                    const size = item.type === 'd' ? 4096 : (item.content ? item.content.length : 0);
                    output.push(`${item.permissions} 1 ${item.owner} ${item.group} ${humanReadable ? humanSize(size) : size} ${item.date} ${entry}${item.type === 'd' ? '/' : (item.type === 'l' ? ' -> ' + item.link : '')}`);
                });
                return output.join('\n');
            } else {
                return filteredEntries.map(entry => {
                    const item = targetDir.content[entry];
                    if (item.type === 'd') return entry + '/';
                    if (item.type === 'l') return entry + '@';
                    if (item.permissions.includes('x')) return entry + '*';
                    return entry;
                }).join('  ');
            }
        }

        function cmdCd(args) {
            if (args.length === 0) {
                ttys[currentState.currentTTY].currentDir = currentState.currentUser === 'root' ? '/root' : `/home/${currentState.currentUser}`;
                return '';
            }
            
            const targetPath = resolvePath(args[0]);
            const targetDir = getDirectoryContents(targetPath);
            
            if (!targetDir) {
                return `cd: ${args[0]}: Arquivo ou diretório não encontrado`;
            }
            
            if (targetDir.type !== 'd') {
                return `cd: ${args[0]}: Não é um diretório`;
            }
            
            ttys[currentState.currentTTY].currentDir = targetPath;
            return '';
        }

        function cmdPwd() {
            return ttys[currentState.currentTTY].currentDir;
        }

        function cmdCat(args, inputContent) {
            if (inputContent) {
                return inputContent;
            }
            
            if (args.length === 0) {
                return 'cat: nenhum arquivo especificado';
            }
            
            let output = [];
            
            for (const arg of args) {
                const targetPath = resolvePath(arg);
                const targetFile = getDirectoryContents(targetPath);
                
                if (!targetFile) {
                    output.push(`cat: ${arg}: Arquivo ou diretório não encontrado`);
                    continue;
                }
                
                if (targetFile.type === 'd') {
                    output.push(`cat: ${arg}: É um diretório`);
                    continue;
                }
                
                output.push(targetFile.content);
            }
            
            return output.join('\n');
        }

        function cmdEcho(args) {
            const processedArgs = args.map(arg => {
                if (arg.startsWith('$')) {
                    const varName = arg.substring(1);
                    switch (varName) {
                        case 'USER':
                        case 'USERNAME':
                            return currentState.currentUser;
                        case 'HOME':
                            return currentState.currentUser === 'root' ? '/root' : `/home/${currentState.currentUser}`;
                        case 'HOSTNAME':
                            return currentState.hostname;
                        case 'PWD':
                            return ttys[currentState.currentTTY].currentDir;
                        case 'SHELL':
                            return '/bin/bash';
                        case 'PATH':
                            return '/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin';
                        case 'LANG':
                            return 'pt_BR.UTF-8';
                        default:
                            return '';
                    }
                }
                return arg;
            });
            
            return processedArgs.join(' ');
        }

        function cmdMkdir(args) {
            if (args.length === 0) {
                return 'mkdir: operando em falta\nTente \'mkdir --help\' para mais informações.';
            }
            
            let createParents = false;
            
            // Processar opções
            args = args.filter(arg => {
                if (arg === '-p' || arg === '--parents') {
                    createParents = true;
                    return false;
                }
                return true;
            });
            
            if (args.length === 0) {
                return 'mkdir: operando em falta\nTente \'mkdir --help\' para mais informações.';
            }
            
            let errors = [];
            
            for (const arg of args) {
                const targetPath = resolvePath(arg);
                
                if (createParents) {
                    // Criar diretórios pais
                    const parts = targetPath.split('/').filter(p => p);
                    let currentPath = '';
                    
                    for (let i = 0; i < parts.length; i++) {
                        currentPath += '/' + parts[i];
                        
                        const currentDir = getDirectoryContents(currentPath);
                        
                        if (!currentDir) {
                            // Verificar se o pai existe
                            const parentPath = currentPath.substring(0, currentPath.lastIndexOf('/'));
                            const parentDir = getDirectoryContents(parentPath);
                            
                            if (!parentDir) {
                                errors.push(`mkdir: não foi possível criar o diretório '${arg}': Caminho não encontrado`);
                                break;
                            }
                            
                            if (parentDir.type !== 'd') {
                                errors.push(`mkdir: não foi possível criar o diretório '${arg}': Não é um diretório`);
                                break;
                            }
                            
                            // Criar diretório
                            parentDir.content[parts[i]] = {
                                type: 'd',
                                permissions: 'drwxr-xr-x',
                                owner: currentState.currentUser,
                                group: currentState.currentUser,
                                content: {},
                                date: getCurrentDate()
                            };
                        } else if (currentDir.type !== 'd') {
                            errors.push(`mkdir: não foi possível criar o diretório '${arg}': Arquivo existe`);
                            break;
                        }
                    }
                } else {
                    const parentDir = getParentDirectory(targetPath);
                    const dirName = targetPath.split('/').pop();
                    
                    if (!parentDir) {
                        errors.push(`mkdir: não foi possível criar o diretório '${arg}': Caminho não encontrado`);
                        continue;
                    }
                    
                    if (parentDir.content[dirName]) {
                        errors.push(`mkdir: não foi possível criar o diretório '${arg}': Arquivo existe`);
                        continue;
                    }
                    
                    // Criar diretório
                    parentDir.content[dirName] = {
                        type: 'd',
                        permissions: 'drwxr-xr-x',
                        owner: currentState.currentUser,
                        group: currentState.currentUser,
                        content: {},
                        date: getCurrentDate()
                    };
                }
            }
            
            return errors.join('\n');
        }

        function cmdRm(args) {
            if (args.length === 0) {
                return 'rm: operando em falta\nTente \'rm --help\' para mais informações.';
            }
            
            let recursive = false;
            let force = false;
            
            // Processar opções
            args = args.filter(arg => {
                if (arg === '-r' || arg === '-R' || arg === '--recursive') {
                    recursive = true;
                    return false;
                }
                if (arg === '-f' || arg === '--force') {
                    force = true;
                    return false;
                }
                if (arg === '-rf' || arg === '-fr') {
                    recursive = true;
                    force = true;
                    return false;
                }
                return true;
            });
            
            if (args.length === 0) {
                return 'rm: operando em falta\nTente \'rm --help\' para mais informações.';
            }
            
            let errors = [];
            
            for (const arg of args) {
                const targetPath = resolvePath(arg);
                const parentDir = getParentDirectory(targetPath);
                const fileName = targetPath.split('/').pop();
                
                if (!parentDir || !parentDir.content[fileName]) {
                    if (!force) {
                        errors.push(`rm: não foi possível remover '${arg}': Arquivo ou diretório não encontrado`);
                    }
                    continue;
                }
                
                const target = parentDir.content[fileName];
                
                if (target.type === 'd' && !recursive) {
                    errors.push(`rm: não foi possível remover '${arg}': É um diretório`);
                    continue;
                }
                
                // Verificar permissões
                if (target.owner !== currentState.currentUser && currentState.currentUser !== 'root') {
                    errors.push(`rm: não foi possível remover '${arg}': Permissão negada`);
                    continue;
                }
                
                // Remover arquivo ou diretório
                delete parentDir.content[fileName];
            }
            
            return errors.join('\n');
        }

        function cmdCp(args) {
            if (args.length < 2) {
                return 'cp: faltando operando de arquivo\nTente \'cp --help\' para mais informações.';
            }
            
            let recursive = false;
            
            // Processar opções
            args = args.filter(arg => {
                if (arg === '-r' || arg === '-R' || arg === '--recursive') {
                    recursive = true;
                    return false;
                }
                return true;
            });
            
            if (args.length < 2) {
                return 'cp: faltando operando de arquivo\nTente \'cp --help\' para mais informações.';
            }
            
            const destPath = resolvePath(args[args.length - 1]);
            const destDir = getDirectoryContents(destPath);
            const sourceArgs = args.slice(0, args.length - 1);
            
            // Se houver múltiplas fontes, o destino deve ser um diretório
            if (sourceArgs.length > 1 && (!destDir || destDir.type !== 'd')) {
                return `cp: o alvo '${args[args.length - 1]}' não é um diretório`;
            }
            
            let errors = [];
            
            for (const sourceArg of sourceArgs) {
                const sourcePath = resolvePath(sourceArg);
                const sourceFile = getDirectoryContents(sourcePath);
                
                if (!sourceFile) {
                    errors.push(`cp: não foi possível acessar '${sourceArg}': Arquivo ou diretório não encontrado`);
                    continue;
                }
                
                // Determinar o caminho de destino
                let finalDestPath;
                if (destDir && destDir.type === 'd') {
                    // Se o destino é um diretório, o nome do arquivo permanece o mesmo
                    finalDestPath = destPath + '/' + sourcePath.split('/').pop();
                } else {
                    finalDestPath = destPath;
                }
                
                // Verificar se é diretório sem a opção recursiva
                if (sourceFile.type === 'd' && !recursive) {
                    errors.push(`cp: omitindo o diretório '${sourceArg}'`);
                    continue;
                }
                
                // Obter o diretório pai do destino
                const destParent = getParentDirectory(finalDestPath);
                const destName = finalDestPath.split('/').pop();
                
                if (!destParent) {
                    errors.push(`cp: não foi possível criar arquivo regular '${finalDestPath}': Caminho não encontrado`);
                    continue;
                }
                
                // Copiar arquivo ou diretório
                if (sourceFile.type === 'd') {
                    // Copiar diretório recursivamente
                    destParent.content[destName] = JSON.parse(JSON.stringify(sourceFile));
                    destParent.content[destName].owner = currentState.currentUser;
                    destParent.content[destName].group = currentState.currentUser;
                    destParent.content[destName].date = getCurrentDate();
                } else {
                    // Copiar arquivo
                    destParent.content[destName] = {
                        type: sourceFile.type,
                        permissions: sourceFile.permissions,
                        owner: currentState.currentUser,
                        group: currentState.currentUser,
                        content: sourceFile.content,
                        date: getCurrentDate()
                    };
                    
                    if (sourceFile.type === 'l') {
                        destParent.content[destName].link = sourceFile.link;
                    }
                }
            }
            
            return errors.join('\n');
        }

        function cmdMv(args) {
            if (args.length < 2) {
                return 'mv: faltando operando de arquivo\nTente \'mv --help\' para mais informações.';
            }
            
            const destPath = resolvePath(args[args.length - 1]);
            const destDir = getDirectoryContents(destPath);
            const sourceArgs = args.slice(0, args.length - 1);
            
            // Se houver múltiplas fontes, o destino deve ser um diretório
            if (sourceArgs.length > 1 && (!destDir || destDir.type !== 'd')) {
                return `mv: o alvo '${args[args.length - 1]}' não é um diretório`;
            }
            
            let errors = [];
            
            for (const sourceArg of sourceArgs) {
                const sourcePath = resolvePath(sourceArg);
                const sourceParent = getParentDirectory(sourcePath);
                const sourceName = sourcePath.split('/').pop();
                
                if (!sourceParent || !sourceParent.content[sourceName]) {
                    errors.push(`mv: não foi possível acessar '${sourceArg}': Arquivo ou diretório não encontrado`);
                    continue;
                }
                
                // Determinar o caminho de destino
                let finalDestPath;
                if (destDir && destDir.type === 'd') {
                    // Se o destino é um diretório, o nome do arquivo permanece o mesmo
                    finalDestPath = destPath + '/' + sourceName;
                } else {
                    finalDestPath = destPath;
                }
                
                // Obter o diretório pai do destino
                const destParent = getParentDirectory(finalDestPath);
                const destName = finalDestPath.split('/').pop();
                
                if (!destParent) {
                    errors.push(`mv: não foi possível mover para '${finalDestPath}': Caminho não encontrado`);
                    continue;
                }
                
                // Verificar permissões
                if ((sourceParent.owner !== currentState.currentUser || destParent.owner !== currentState.currentUser) && 
                    currentState.currentUser !== 'root') {
                    errors.push(`mv: não foi possível mover '${sourceArg}' para '${finalDestPath}': Permissão negada`);
                    continue;
                }
                
                // Mover arquivo ou diretório
                destParent.content[destName] = sourceParent.content[sourceName];
                delete sourceParent.content[sourceName];
            }
            
            return errors.join('\n');
        }

        function cmdTouch(args) {
            if (args.length === 0) {
                return 'touch: operando em falta\nTente \'touch --help\' para mais informações.';
            }
            
            let errors = [];
            
            for (const arg of args) {
                const targetPath = resolvePath(arg);
                const parentDir = getParentDirectory(targetPath);
                const fileName = targetPath.split('/').pop();
                
                if (!parentDir) {
                    errors.push(`touch: não foi possível tocar '${arg}': Caminho não encontrado`);
                    continue;
                }
                
                // Se o arquivo já existe, atualizar a data
                if (parentDir.content[fileName]) {
                    parentDir.content[fileName].date = getCurrentDate();
                } else {
                    // Criar um arquivo vazio
                    parentDir.content[fileName] = {
                        type: '-',
                        permissions: '-rw-r--r--',
                        owner: currentState.currentUser,
                        group: currentState.currentUser,
                        content: '',
                        date: getCurrentDate()
                    };
                }
            }
            
            return errors.join('\n');
        }

        function cmdGrep(args, inputContent) {
            if (args.length === 0) {
                return 'grep: nenhum padrão especificado\nTente \'grep --help\' para mais informações.';
            }
            
            let pattern = args[0];
            let ignoreCase = false;
            let invertMatch = false;
            let lineNumbers = false;
            let count = false;
            
            // Processar opções
            args = args.filter(arg => {
                if (arg === '-i' || arg === '--ignore-case') {
                    ignoreCase = true;
                    return false;
                }
                if (arg === '-v' || arg === '--invert-match') {
                    invertMatch = true;
                    return false;
                }
                if (arg === '-n' || arg === '--line-number') {
                    lineNumbers = true;
                    return false;
                }
                if (arg === '-c' || arg === '--count') {
                    count = true;
                    return false;
                }
                return true;
            });
            
            if (args.length === 0) {
                return 'grep: nenhum padrão especificado\nTente \'grep --help\' para mais informações.';
            }
            
            pattern = args[0];
            const files = args.slice(1);
            
            // Se não há arquivos e não há entrada redirecionada, erro
            if (files.length === 0 && !inputContent) {
                return 'grep: nenhum arquivo de entrada especificado\nTente \'grep --help\' para mais informações.';
            }
            
            let results = [];
            
            // Processar entrada redirecionada
            if (inputContent) {
                const lines = inputContent.split('\n');
                let matchCount = 0;
                
                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i];
                    const regex = new RegExp(pattern, ignoreCase ? 'i' : '');
                    const matches = regex.test(line);
                    
                    if ((matches && !invertMatch) || (!matches && invertMatch)) {
                        if (count) {
                            matchCount++;
                        } else {
                            if (lineNumbers) {
                                results.push(`${i + 1}:${line}`);
                            } else {
                                results.push(line);
                            }
                        }
                    }
                }
                
                if (count) {
                    results.push(matchCount.toString());
                }
            }
            
            // Processar arquivos
            for (const file of files) {
                const targetPath = resolvePath(file);
                const targetFile = getDirectoryContents(targetPath);
                
                if (!targetFile) {
                    results.push(`grep: ${file}: Arquivo ou diretório não encontrado`);
                    continue;
                }
                
                if (targetFile.type === 'd') {
                    results.push(`grep: ${file}: É um diretório`);
                    continue;
                }
                
                const lines = targetFile.content.split('\n');
                let matchCount = 0;
                
                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i];
                    const regex = new RegExp(pattern, ignoreCase ? 'i' : '');
                    const matches = regex.test(line);
                    
                    if ((matches && !invertMatch) || (!matches && invertMatch)) {
                        if (count) {
                            matchCount++;
                        } else {
                            if (files.length > 1) {
                                if (lineNumbers) {
                                    results.push(`${file}:${i + 1}:${line}`);
                                } else {
                                    results.push(`${file}:${line}`);
                                }
                            } else {
                                if (lineNumbers) {
                                    results.push(`${i + 1}:${line}`);
                                } else {
                                    results.push(line);
                                }
                            }
                        }
                    }
                }
                
                if (count) {
                    if (files.length > 1) {
                        results.push(`${file}:${matchCount}`);
                    } else {
                        results.push(matchCount.toString());
                    }
                }
            }
            
            return results.join('\n');
        }

        function cmdFind(args) {
            if (args.length === 0) {
                return 'find: nenhum caminho especificado';
            }
            
            const startPath = resolvePath(args[0]);
            const startDir = getDirectoryContents(startPath);
            
            if (!startDir) {
                return `find: '${args[0]}': Arquivo ou diretório não encontrado`;
            }
            
            if (startDir.type !== 'd') {
                return startDir;
            }
            
            let namePattern = null;
            let typeFilter = null;
            
            // Processar opções
            for (let i = 1; i < args.length; i++) {
                if (args[i] === '-name' && i + 1 < args.length) {
                    namePattern = args[i + 1].replace(/\*/g, '.*').replace(/\?/g, '.');
                    i++;
                } else if (args[i] === '-type' && i + 1 < args.length) {
                    typeFilter = args[i + 1];
                    i++;
                }
            }
            
            // Função recursiva para encontrar arquivos
            function findRecursive(dir, path, results) {
                const entries = Object.keys(dir.content);
                
                for (const entry of entries) {
                    const entryPath = path + '/' + entry;
                    const item = dir.content[entry];
                    
                    // Verificar filtro de tipo
                    if (typeFilter) {
                        if (typeFilter === 'f' && item.type !== '-') continue;
                        if (typeFilter === 'd' && item.type !== 'd') continue;
                        if (typeFilter === 'l' && item.type !== 'l') continue;
                    }
                    
                    // Verificar filtro de nome
                    if (namePattern) {
                        const regex = new RegExp('^' + namePattern + '$');
                        if (!regex.test(entry)) {
                            if (item.type === 'd') {
                                findRecursive(item, entryPath, results);
                            }
                            continue;
                        }
                    }
                    
                    results.push(entryPath);
                    
                    // Recursão para diretórios
                    if (item.type === 'd') {
                        findRecursive(item, entryPath, results);
                    }
                }
            }
            
            let results = [];
            findRecursive(startDir, startPath, results);
            
            return results.join('\n');
        }

        function cmdApt(args) {
            if (args.length === 0) {
                return 'apt 2.6.1 (amd64)\nUso: apt [opções] comando\n\nComandos mais utilizados:\n  update - Atualiza a lista de pacotes disponíveis\n  upgrade - Realiza uma atualização\n  install - Instala novos pacotes\n  remove - Remove pacotes\n  list - Lista pacotes baseado no nome\n  search - Busca no pacote por detalhes\n  show - Mostra detalhes do pacote\n  clean - Limpa arquivos baixados localmente\n  autoremove - Remove pacotes instalados automaticamente\n  -h - Mostra texto de ajuda para o comando dado';
            }
            
            const command = args[0];
            
            if (command === 'update') {
                loadingElement.style.display = 'flex';
                loadingTextElement.textContent = 'Atualizando listas de pacotes...';
                
                setTimeout(() => {
                    loadingElement.style.display = 'none';
                    
                    const output = [
                        'Obter:1 http://deb.debian.org/debian bookworm InRelease [151 kB]',
                        'Obter:2 http://deb.debian.org/debian bookworm/main amd64 Packages [9.262 kB]',
                        'Obter:3 http://security.debian.org/debian-security bookworm-security InRelease [48,0 kB]',
                        'Obter:4 http://security.debian.org/debian-security bookworm-security/main amd64 Packages [167 kB]',
                        'Baixados 9.628 kB em 2s (4.814 kB/s)',
                        'Lendo listas de pacotes... Pronto'
                    ];
                    
                    output.forEach(line => addOutput(line));
                    
                    currentState.aptUpdated = true;
                    renderPrompt();
                }, 3000);
                
                return null;
            } else if (command === 'upgrade') {
                if (!currentState.aptUpdated) {
                    return 'E: As listas de pacotes ou os arquivos de status não puderam ser analisados ou abertos.\nTente executar "apt update" primeiro.';
                }
                
                loadingElement.style.display = 'flex';
                loadingTextElement.textContent = 'Calculando atualização...';
                
                setTimeout(() => {
                    loadingElement.style.display = 'none';
                    
                    const output = [
                        'Lendo listas de pacotes... Pronto',
                        'Construindo árvore de dependências... Pronto',
                        'Lendo informação de estado... Pronto',
                        'Calculando atualização... Pronto',
                        '0 pacotes atualizados, 0 pacotes novos instalados, 0 a serem removidos e 0 não atualizados.'
                    ];
                    
                    output.forEach(line => addOutput(line));
                    renderPrompt();
                }, 2000);
                
                return null;
            } else if (command === 'install') {
                if (args.length < 2) {
                    return 'E: Nenhum pacote foi especificado para instalação.';
                }
                
                if (!currentState.aptUpdated) {
                    return 'E: As listas de pacotes ou os arquivos de status não puderam ser analisados ou abertos.\nTente executar "apt update" primeiro.';
                }
                
                const packageNames = args.slice(1);
                const invalidPackages = [];
                const alreadyInstalledPackages = [];
                const toInstallPackages = [];
                
                // Verificar pacotes
                for (const pkgName of packageNames) {
                    if (!AVAILABLE_PACKAGES[pkgName]) {
                        invalidPackages.push(pkgName);
                    } else if (currentState.installedPackages[pkgName]) {
                        alreadyInstalledPackages.push(pkgName);
                    } else {
                        toInstallPackages.push(pkgName);
                    }
                }
                
                if (invalidPackages.length > 0) {
                    return `E: Não foi possível encontrar o pacote ${invalidPackages.join(', ')}`;
                }
                
                if (alreadyInstalledPackages.length > 0 && toInstallPackages.length === 0) {
                    return `${alreadyInstalledPackages.map(pkg => `${pkg} já é a versão mais recente (${AVAILABLE_PACKAGES[pkg].version}).`).join('\n')}`;
                }
                
                if (toInstallPackages.length === 0) {
                    return 'Nenhum pacote para instalar.';
                }
                
                // Verificar dependências
                const allDependencies = new Set();
                for (const pkg of toInstallPackages) {
                    AVAILABLE_PACKAGES[pkg].dependencies.forEach(dep => {
                        if (!currentState.installedPackages[dep]) {
                            allDependencies.add(dep);
                        }
                    });
                }
                
                // Simular instalação
                loadingElement.style.display = 'flex';
                loadingTextElement.textContent = 'Instalando pacotes...';
                
                setTimeout(() => {
                    const output = [
                        'Lendo listas de pacotes... Pronto',
                        'Construindo árvore de dependências... Pronto',
                        'Lendo informação de estado... Pronto'
                    ];
                    
                    if (allDependencies.size > 0) {
                        output.push('Os pacotes adicionais seguintes serão instalados:');
                        output.push(`  ${Array.from(allDependencies).join(' ')}`);
                    }
                    
                    output.push('Os NOVOS pacotes seguintes serão instalados:');
                    output.push(`  ${toInstallPackages.join(' ')}${allDependencies.size > 0 ? ' ' + Array.from(allDependencies).join(' ') : ''}`);
                    
                    const totalPackages = toInstallPackages.length + allDependencies.size;
                    output.push(`0 pacotes atualizados, ${totalPackages} pacotes novos instalados, 0 a serem removidos e 0 não atualizados.`);
                    
                    let totalSize = 0;
                    [...toInstallPackages, ...allDependencies].forEach(pkg => {
                        if (AVAILABLE_PACKAGES[pkg]) {
                            const sizeStr = AVAILABLE_PACKAGES[pkg].size;
                            const size = parseFloat(sizeStr);
                            if (!isNaN(size)) {
                                totalSize += size;
                            }
                        }
                    });
                    
                    output.push(`Necessário obter ${totalSize.toFixed(1)}MB de arquivos.`);
                    output.push(`Depois desta operação, ${(totalSize * 2.5).toFixed(1)}MB adicionais de espaço em disco serão usados.`);
                    
                    let progress = 0;
                    const totalProgress = 100;
                    const interval = setInterval(() => {
                        progress += 5;
                        loadingTextElement.textContent = `Instalando pacotes... ${progress}%`;
                        
                        if (progress >= totalProgress) {
                            clearInterval(interval);
                            loadingElement.style.display = 'none';
                            
                            // Adicionar detalhes da instalação
                            for (const pkg of toInstallPackages) {
                                output.push(`Selecionando pacote ${pkg} previamente não selecionado.`);
                                output.push(`Preparando para desempacotar .../packages/${pkg}_${AVAILABLE_PACKAGES[pkg].version}_amd64.deb...`);
                                output.push(`Desempacotando ${pkg} (${AVAILABLE_PACKAGES[pkg].version})...`);
                                output.push(`Configurando ${pkg} (${AVAILABLE_PACKAGES[pkg].version})...`);
                            }
                            
                            for (const dep of allDependencies) {
                                if (AVAILABLE_PACKAGES[dep]) {
                                    output.push(`Selecionando pacote ${dep} previamente não selecionado.`);
                                    output.push(`Preparando para desempacotar .../packages/${dep}_${AVAILABLE_PACKAGES[dep].version}_amd64.deb...`);
                                    output.push(`Desempacotando ${dep} (${AVAILABLE_PACKAGES[dep].version})...`);
                                    output.push(`Configurando ${dep} (${AVAILABLE_PACKAGES[dep].version})...`);
                                }
                            }
                            
                            output.push('Processando gatilhos para man-db (2.11.2-2)...');
                            
                            // Marcar pacotes como instalados
                            for (const pkg of toInstallPackages) {
                                currentState.installedPackages[pkg] = {
                                    version: AVAILABLE_PACKAGES[pkg].version,
                                    installDate: getCurrentDate()
                                };
                                
                                // Iniciar serviço se aplicável
                                if (pkg === 'apache2' || pkg === 'nginx' || pkg === 'ssh' || pkg === 'mysql-server') {
                                    const serviceName = pkg === 'ssh' ? 'ssh' : pkg;
                                    if (currentState.services[serviceName]) {
                                        currentState.services[serviceName].status = 'running';
                                    }
                                }
                            }
                            
                            // Instalar dependências
                            for (const dep of allDependencies) {
                                if (AVAILABLE_PACKAGES[dep]) {
                                    currentState.installedPackages[dep] = {
                                        version: AVAILABLE_PACKAGES[dep].version,
                                        installDate: getCurrentDate()
                                    };
                                }
                            }
                            
                            output.forEach(line => addOutput(line));
                            renderPrompt();
                        }
                    }, 200);
                }, 1000);
                
                return null;
            } else if (command === 'remove' || command === 'purge') {
                if (args.length < 2) {
                    return `E: Nenhum pacote foi especificado para ${command === 'purge' ? 'expurgação' : 'remoção'}.`;
                }
                
                const packageNames = args.slice(1);
                const invalidPackages = [];
                const notInstalledPackages = [];
                const toRemovePackages = [];
                
                // Verificar pacotes
                for (const pkgName of packageNames) {
                    if (!AVAILABLE_PACKAGES[pkgName]) {
                        invalidPackages.push(pkgName);
                    } else if (!currentState.installedPackages[pkgName]) {
                        notInstalledPackages.push(pkgName);
                    } else {
                        toRemovePackages.push(pkgName);
                    }
                }
                
                if (invalidPackages.length > 0) {
                    return `E: Não foi possível encontrar o pacote ${invalidPackages.join(', ')}`;
                }
                
                if (notInstalledPackages.length > 0 && toRemovePackages.length === 0) {
                    return `Os pacotes a seguir não foram instalados, então não serão removidos:\n${notInstalledPackages.join(' ')}`;
                }
                
                if (toRemovePackages.length === 0) {
                    return 'Nenhum pacote para remover.';
                }
                
                // Simular remoção
                loadingElement.style.display = 'flex';
                loadingTextElement.textContent = 'Removendo pacotes...';
                
                setTimeout(() => {
                    const output = [
                        'Lendo listas de pacotes... Pronto',
                        'Construindo árvore de dependências... Pronto',
                        'Lendo informação de estado... Pronto'
                    ];
                    
                    output.push('Os pacotes seguintes serão REMOVIDOS:');
                    output.push(`  ${toRemovePackages.join(' ')}`);
                    
                    output.push(`0 pacotes atualizados, 0 pacotes novos instalados, ${toRemovePackages.length} a serem removidos e 0 não atualizados.`);
                    
                    let totalSize = 0;
                    toRemovePackages.forEach(pkg => {
                        if (AVAILABLE_PACKAGES[pkg]) {
                            const sizeStr = AVAILABLE_PACKAGES[pkg].size;
                            const size = parseFloat(sizeStr);
                            if (!isNaN(size)) {
                                totalSize += size;
                            }
                        }
                    });
                    
                    output.push(`Depois desta operação, ${totalSize.toFixed(1)}MB de espaço em disco serão liberados.`);
                    
                    let progress = 0;
                    const totalProgress = 100;
                    const interval = setInterval(() => {
                        progress += 5;
                        loadingTextElement.textContent = `Removendo pacotes... ${progress}%`;
                        
                        if (progress >= totalProgress) {
                            clearInterval(interval);
                            loadingElement.style.display = 'none';
                            
                            // Adicionar detalhes da remoção
                            for (const pkg of toRemovePackages) {
                                output.push(`Removendo ${pkg} (${AVAILABLE_PACKAGES[pkg].version})...`);
                                
                                // Parar serviço se aplicável
                                if (pkg === 'apache2' || pkg === 'nginx' || pkg === 'ssh' || pkg === 'mysql-server') {
                                    const serviceName = pkg === 'ssh' ? 'ssh' : pkg;
                                    if (currentState.services[serviceName]) {
                                        currentState.services[serviceName].status = 'stopped';
                                    }
                                }
                                
                                // Remover pacote
                                delete currentState.installedPackages[pkg];
                            }
                            
                            output.push('Processando gatilhos para man-db (2.11.2-2)...');
                            
                            output.forEach(line => addOutput(line));
                            renderPrompt();
                        }
                    }, 200);
                }, 1000);
                
                return null;
            } else if (command === 'list' || command === 'list' && args[1] === '--installed') {
                const installedPackages = Object.keys(currentState.installedPackages);
                
                if (installedPackages.length === 0) {
                    return 'Nenhum pacote instalado.';
                }
                
                return installedPackages.map(pkg => {
                    const info = currentState.installedPackages[pkg];
                    return `${pkg}/${currentState.hostname} ${info.version} amd64 [instalado,local]`;
                }).join('\n');
            } else if (command === 'search') {
                if (args.length < 2) {
                    return 'E: Você deve fornecer pelo menos um padrão de pesquisa';
                }
                
                const searchPattern = args[1].toLowerCase();
                const results = [];
                
                for (const pkgName in AVAILABLE_PACKAGES) {
                    if (pkgName.toLowerCase().includes(searchPattern) || 
                        AVAILABLE_PACKAGES[pkgName].description.toLowerCase().includes(searchPattern)) {
                        results.push(`${pkgName} - ${AVAILABLE_PACKAGES[pkgName].description}`);
                    }
                }
                
                if (results.length === 0) {
                    return `Nenhum pacote encontrado correspondendo a '${searchPattern}'`;
                }
                
                return results.join('\n');
            } else if (command === 'show') {
                if (args.length < 2) {
                    return 'E: Você deve fornecer pelo menos um nome de pacote';
                }
                
                const pkgName = args[1];
                
                if (!AVAILABLE_PACKAGES[pkgName]) {
                    return `E: Nenhum pacote encontrado correspondendo a '${pkgName}'`;
                }
                
                const pkg = AVAILABLE_PACKAGES[pkgName];
                const isInstalled = pkgName in currentState.installedPackages;
                
                return [
                    `Package: ${pkgName}`,
                    `Version: ${pkg.version}`,
                    `Priority: optional`,
                    `Section: ${pkgName.includes('lib') ? 'libs' : 'admin'}`,
                    `Maintainer: Debian Developers <debian-devel@lists.debian.org>`,
                    `Installed-Size: ${parseFloat(pkg.size) * 1024}`,
                    `Depends: ${pkg.dependencies.join(', ') || 'none'}`,
                    `Homepage: http://www.debian.org/`,
                    `Download-Size: ${pkg.size}`,
                    `APT-Sources: http://deb.debian.org/debian bookworm/main amd64 Packages`,
                    `Description: ${pkg.description}`,
                    ` ${pkg.description}`,
                    ``,
                    `N: ${isInstalled ? 'Instalado: sim' : 'Não instalado'}`
                ].join('\n');
            } else if (command === 'clean') {
                return 'Del /var/cache/apt/archives/*.deb\nDel /var/cache/apt/archives/partial/*.deb';
            } else if (command === 'autoremove') {
                return 'Lendo listas de pacotes... Pronto\nConstruindo árvore de dependências... Pronto\nLendo informação de estado... Pronto\n0 pacotes atualizados, 0 pacotes novos instalados, 0 a serem removidos e 0 não atualizados.';
            } else {
                return `Comando apt '${command}' inválido\nTente 'apt --help' ou 'apt --help-cmd' para mais informações.`;
            }
        }

        function cmdDpkg(args) {
            if (args.length === 0) {
                return 'Uso: dpkg [opções] comando\n\nComandos:\n  -i|--install      <arquivo.deb> ... | -R|--recursive <diretório> ...\n  --unpack          <arquivo.deb> ... | -R|--recursive <diretório> ...\n  -A|--record-avail <arquivo.deb> ... | -R|--recursive <diretório> ...\n  --configure        <pacote> ... | -a|--pending\n  --triggers-only    <pacote> ... | -a|--pending\n  -r|--remove        <pacote> ... | -a|--pending\n  -P|--purge         <pacote> ... | -a|--pending\n  -V|--verify <pacote> ...        Verifica a integridade do(s) pacote(s).\n  --get-selections [<padrão> ...] Envia a lista de seleções para stdout.\n  --set-selections                Define a lista de seleções a partir de stdin.\n  --clear-selections              Não marca nada como selecionado.\n  --update-avail [<arquivo-packages>]\n                          Substitui informação de pacotes disponíveis.\n  --merge-avail [<arquivo-packages>]\n                          Mescla com a informação do arquivo.\n  --clear-avail                   Limpa informação sobre disponibilidade existente.\n  --forget-old-unavail            Esquece informação de pacotes não instalados\n                                  e indisponíveis.\n  -s|--status <pacote> ...        Mostra detalhes sobre o estado do pacote.\n  -p|--print-avail <pacote> ...   Mostra detalhes sobre a versão disponível.\n  -L|--listfiles <pacote> ...     Lista os arquivos instalados pelo(s) pacote(s).\n  -l|--list [<padrão> ...]        Lista os pacotes resumidamente.\n  -S|--search <padrão> ...        Localiza o(s) pacote(s) contendo arquivo(s).\n  -C|--audit [<pacote> ...]       Verifica por pacote(s) quebrado(s).\n  --yet-to-unpack                 Mostra pacotes selecionados para instalação.\n  --predep-package                Mostra pré-dependências a desempacotar.\n  --add-architecture <arch>       Adiciona <arch> à lista de arquiteturas.\n  --remove-architecture <arch>    Remove <arch> da lista de arquiteturas.\n  --print-architecture            Mostra a arquitetura do dpkg.\n  --print-foreign-architectures   Mostra arquiteturas estrangeiras permitidas.\n  --assert-help                   Exibe ajuda sobre as asserções da versão.\n  --assert-<recurso>              Afirma suporte para o recurso especificado.\n  --validate-<coisa> <texto>      Valida o <texto> para <coisa>.\n  --compare-versions <a> <op> <b> Compara números de versão - veja abaixo.\n  --force-help                    Exibe ajuda sobre as opções de forçar.\n  -Dh|--debug=help                Exibe ajuda sobre depuração.\n\n  -?, --help                      Exibe esta mensagem de ajuda.\n      --version                   Exibe a versão.';
            }
            
            const command = args[0];
            
            if (command === '--list' || command === '-l') {
                const installedPackages = Object.keys(currentState.installedPackages);
                
                if (installedPackages.length === 0) {
                    return 'Nenhum pacote instalado.';
                }
                
                let output = [
                    'Desired=Unknown/Install/Remove/Purge/Hold',
                    '| Status=Not/Inst/Conf-files/Unpacked/halF-conf/Half-inst/trig-aWait/Trig-pend',
                    '|/ Err?=(none)/Reinst-required (Status,Err: uppercase=bad)',
                    '||/ Nome                                Versão            Arquitetura Descrição',
                    '+++-====================================-=================-============-================================================================================'
                ];
                
                installedPackages.sort().forEach(pkg => {
                    const info = currentState.installedPackages[pkg];
                    const desc = AVAILABLE_PACKAGES[pkg] ? AVAILABLE_PACKAGES[pkg].description : '';
                    output.push(`ii  ${pkg.padEnd(35)} ${info.version.padEnd(17)} amd64        ${desc}`);
                });
                
                return output.join('\n');
            } else if (command === '--status' || command === '-s') {
                if (args.length < 2) {
                    return 'dpkg: erro: --status precisa de pelo menos um argumento de nome de pacote';
                }
                
                const pkgName = args[1];
                
                if (!currentState.installedPackages[pkgName]) {
                    return `dpkg-query: nenhum pacote correspondente a ${pkgName}`;
                }
                
                const info = currentState.installedPackages[pkgName];
                const pkg = AVAILABLE_PACKAGES[pkgName] || { description: '', dependencies: [] };
                
                return [
                    `Package: ${pkgName}`,
                    `Status: install ok installed`,
                    `Priority: optional`,
                    `Section: ${pkgName.includes('lib') ? 'libs' : 'admin'}`,
                    `Installed-Size: ${parseFloat(pkg.size || '1MB') * 1024}`,
                    `Maintainer: Debian Developers <debian-devel@lists.debian.org>`,
                    `Architecture: amd64`,
                    `Version: ${info.version}`,
                    `Depends: ${pkg.dependencies.join(', ') || 'none'}`,
                    `Description: ${pkg.description}`,
                    ` ${pkg.description}`
                ].join('\n');
            } else if (command === '--search' || command === '-S') {
                if (args.length < 2) {
                    return 'dpkg: erro: --search precisa de pelo menos um argumento de padrão de arquivo';
                }
                
                const pattern = args[1];
                return `dpkg-query: nenhum caminho encontrado correspondendo ao padrão ${pattern}`;
            } else if (command === '--listfiles' || command === '-L') {
                if (args.length < 2) {
                    return 'dpkg: erro: --listfiles precisa de pelo menos um argumento de nome de pacote';
                }
                
                const pkgName = args[1];
                
                if (!currentState.installedPackages[pkgName]) {
                    return `dpkg-query: pacote '${pkgName}' não é conhecido no banco de dados`;
                }
                
                // Simulação simples de arquivos de pacote
                const commonPaths = [
                    `/usr/bin/${pkgName}`,
                    `/usr/share/doc/${pkgName}`,
                    `/usr/share/man/man1/${pkgName}.1.gz`,
                    `/usr/lib/${pkgName}`,
                    `/etc/${pkgName}`
                ];
                
                return commonPaths.join('\n');
            } else {
                return `dpkg: erro: opção desconhecida ${command}\n\nTente 'dpkg --help' para mais informações sobre os comandos disponíveis.`;
            }
        }

        function cmdIp(args) {
            if (args.length === 0) {
                return 'Uso: ip [ OPTIONS ] OBJECT { COMMAND | help }\n       ip [ -force ] -batch filename\nOBJECT := { link | address | addrlabel | route | rule | neigh | ntable |\n       tunnel | tuntap | maddress | mroute | mrule | monitor | xfrm |\n       netns | l2tp | macsec | tcp_metrics | token | netconf | ila |\n       vrf | sr | nexthop | mptcp }\n       ip [ OPTIONS ] OBJECT { COMMAND | help }';
            }
            
            const object = args[0];
            
            if (object === 'address' || object === 'addr' || object === 'a') {
                const command = args.length > 1 ? args[1] : 'show';
                
                if (command === 'show' || command === 's') {
                    const iface = args.length > 2 ? args[2] : null;
                    
                    let output = [];
                    
                    for (const [name, data] of Object.entries(currentState.networkInterfaces)) {
                        if (iface && iface !== name) continue;
                        
                        if (name === 'lo') {
                            output.push(`1: ${name}: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000`);
                            output.push(`    inet ${data.address}/8 scope host lo`);
                            output.push(`       valid_lft forever preferred_lft forever`);
                        } else {
                            const idx = name === 'eth0' ? 2 : 3;
                            output.push(`${idx}: ${name}: <BROADCAST,MULTICAST${data.status === 'up' ? ',UP,LOWER_UP' : ''}> mtu 1500 qdisc pfifo_fast state ${data.status.toUpperCase()} group default qlen 1000`);
                            
                            if (data.address) {
                                output.push(`    inet ${data.address}/24 brd ${data.address.split('.').slice(0, 3).join('.')}.255 scope global ${name}`);
                                output.push(`       valid_lft forever preferred_lft forever`);
                            }
                            
                            const mac = name === 'eth0' ? '08:00:27:a9:7d:95' : '08:00:27:a9:7d:ab';
                            output.push(`    link/ether ${mac} brd ff:ff:ff:ff:ff:ff`);
                        }
                    }
                    
                    return output.join('\n');
                } else if (command === 'add') {
                    if (args.length < 4) {
                        return 'Uso: ip address add IFADDR dev IFNAME';
                    }
                    
                    const addrIndex = args.indexOf('add') + 1;
                    const devIndex = args.indexOf('dev');
                    
                    if (addrIndex >= args.length || devIndex === -1 || devIndex + 1 >= args.length) {
                        return 'Uso: ip address add IFADDR dev IFNAME';
                    }
                    
                    const addr = args[addrIndex];
                    const iface = args[devIndex + 1];
                    
                    if (!currentState.networkInterfaces[iface]) {
                        return `Error: Interface "${iface}" não existe.`;
                    }
                    
                    // Validar formato de IP
                    const ipPattern = /^(\d{1,3})\.(\d{1,3})\.(\d{1,3})\.(\d{1,3})(\/\d{1,2})?$/;
                    if (!ipPattern.test(addr)) {
                        return `Error: Formato de endereço inválido: "${addr}"`;
                    }
                    
                    // Extrair IP e máscara
                    const parts = addr.split('/');
                    const ip = parts[0];
                    const mask = parts.length > 1 ? parseInt(parts[1]) : 24;
                    
                    // Verificar se IP é válido
                    const octets = ip.split('.').map(Number);
                    if (octets.some(octet => octet < 0 || octet > 255)) {
                        return `Error: Endereço IP inválido: "${ip}"`;
                    }
                    
                    // Atualizar interface
                    currentState.networkInterfaces[iface].address = ip;
                    currentState.networkInterfaces[iface].netmask = maskToNetmask(mask);
                    currentState.networkInterfaces[iface].status = 'up';
                    
                    // Atualizar arquivo interfaces
                    updateInterfacesFile(iface, ip, mask);
                    
                    return '';
                } else if (command === 'del') {
                    if (args.length < 4) {
                        return 'Uso: ip address del IFADDR dev IFNAME';
                    }
                    
                    const addrIndex = args.indexOf('del') + 1;
                    const devIndex = args.indexOf('dev');
                    
                    if (addrIndex >= args.length || devIndex === -1 || devIndex + 1 >= args.length) {
                        return 'Uso: ip address del IFADDR dev IFNAME';
                    }
                    
                    const addr = args[addrIndex];
                    const iface = args[devIndex + 1];
                    
                    if (!currentState.networkInterfaces[iface]) {
                        return `Error: Interface "${iface}" não existe.`;
                    }
                    
                    // Remover endereço
                    currentState.networkInterfaces[iface].address = '';
                    currentState.networkInterfaces[iface].netmask = '';
                    
                    return '';
                } else {
                    return `Objeto "${object}" com comando "${command}" não é conhecido, tentar "ip ${object} help".`;
                }
            } else if (object === 'link') {
                const command = args.length > 1 ? args[1] : 'show';
                
                if (command === 'show' || command === 'list' || command === 'ls') {
                    const iface = args.length > 2 ? args[2] : null;
                    
                    let output = [];
                    
                    for (const [name, data] of Object.entries(currentState.networkInterfaces)) {
                        if (iface && iface !== name) continue;
                        
                        if (name === 'lo') {
                            output.push(`1: ${name}: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000`);
                            output.push(`    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00`);
                        } else {
                            const idx = name === 'eth0' ? 2 : 3;
                            output.push(`${idx}: ${name}: <BROADCAST,MULTICAST${data.status === 'up' ? ',UP,LOWER_UP' : ''}> mtu 1500 qdisc pfifo_fast state ${data.status.toUpperCase()} mode DEFAULT group default qlen 1000`);
                            
                            const mac = name === 'eth0' ? '08:00:27:a9:7d:95' : '08:00:27:a9:7d:ab';
                            output.push(`    link/ether ${mac} brd ff:ff:ff:ff:ff:ff`);
                        }
                    }
                    
                    return output.join('\n');
                } else if (command === 'set') {
                    if (args.length < 3) {
                        return 'Uso: ip link set IFNAME [up|down]';
                    }
                    
                    const iface = args[2];
                    
                    if (!currentState.networkInterfaces[iface]) {
                        return `Error: Interface "${iface}" não existe.`;
                    }
                    
                    let state = null;
                    for (let i = 3; i < args.length; i++) {
                        if (args[i] === 'up' || args[i] === 'down') {
                            state = args[i];
                            break;
                        }
                    }
                    
                    if (state) {
                        currentState.networkInterfaces[iface].status = state;
                    }
                    
                    return '';
                } else {
                    return `Objeto "${object}" com comando "${command}" não é conhecido, tentar "ip ${object} help".`;
                }
            } else if (object === 'route') {
                const command = args.length > 1 ? args[1] : 'show';
                
                if (command === 'show' || command === 'list' || command === 'ls') {
                    return '10.0.2.0/24 dev eth0 proto kernel scope link src 10.0.2.15 \n169.254.0.0/16 dev eth0 scope link metric 1000 \ndefault via 10.0.2.2 dev eth0 proto dhcp src 10.0.2.15 metric 100 ';
                } else if (command === 'add') {
                    // Simulação simples de adição de rota
                    return '';
                } else if (command === 'del') {
                    // Simulação simples de remoção de rota
                    return '';
                } else {
                    return `Objeto "${object}" com comando "${command}" não é conhecido, tentar "ip ${object} help".`;
                }
            } else {
                return `Objeto "${object}" não é conhecido, tentar "ip help".`;
            }
        }

        function cmdIfconfig(args) {
            if (args.length === 0) {
                // Mostrar todas as interfaces ativas
                let output = [];
                
                for (const [name, data] of Object.entries(currentState.networkInterfaces)) {
                    if (data.status !== 'up') continue;
                    
                    if (name === 'lo') {
                        output.push(`${name}: flags=73<UP,LOOPBACK,RUNNING>  mtu 65536`);
                        output.push(`        inet ${data.address}  netmask 255.0.0.0`);
                        output.push(`        loop  txqueuelen 1000  (Local Loopback)`);
                        output.push(`        RX packets 0  bytes 0 (0.0 B)`);
                        output.push(`        RX errors 0  dropped 0  overruns 0  frame 0`);
                        output.push(`        TX packets 0  bytes 0 (0.0 B)`);
                        output.push(`        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0`);
                        output.push(``);
                    } else {
                        output.push(`${name}: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500`);
                        if (data.address) {
                            output.push(`        inet ${data.address}  netmask ${data.netmask}  broadcast ${data.address.split('.').slice(0, 3).join('.')}.255`);
                        }
                        const mac = name === 'eth0' ? '08:00:27:a9:7d:95' : '08:00:27:a9:7d:ab';
                        output.push(`        ether ${mac}  txqueuelen 1000  (Ethernet)`);
                        output.push(`        RX packets 8893  bytes 1207312 (1.1 MiB)`);
                        output.push(`        RX errors 0  dropped 0  overruns 0  frame 0`);
                        output.push(`        TX packets 6145  bytes 977581 (954.6 KiB)`);
                        output.push(`        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0`);
                        output.push(``);
                    }
                }
                
                return output.join('\n');
            } else {
                const iface = args[0];
                
                // Verificar se interface existe
                if (!currentState.networkInterfaces[iface]) {
                    return `${iface}: error fetching interface information: Device not found`;
                }
                
                if (args.length === 1) {
                    // Mostrar uma interface específica
                    const data = currentState.networkInterfaces[iface];
                    let output = [];
                    
                    if (iface === 'lo') {
                        output.push(`${iface}: flags=73<UP,LOOPBACK,RUNNING>  mtu 65536`);
                        output.push(`        inet ${data.address}  netmask 255.0.0.0`);
                        output.push(`        loop  txqueuelen 1000  (Local Loopback)`);
                        output.push(`        RX packets 0  bytes 0 (0.0 B)`);
                        output.push(`        RX errors 0  dropped 0  overruns 0  frame 0`);
                        output.push(`        TX packets 0  bytes 0 (0.0 B)`);
                        output.push(`        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0`);
                    } else {
                        output.push(`${iface}: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500`);
                        if (data.address) {
                            output.push(`        inet ${data.address}  netmask ${data.netmask}  broadcast ${data.address.split('.').slice(0, 3).join('.')}.255`);
                        }
                        const mac = iface === 'eth0' ? '08:00:27:a9:7d:95' : '08:00:27:a9:7d:ab';
                        output.push(`        ether ${mac}  txqueuelen 1000  (Ethernet)`);
                        output.push(`        RX packets 8893  bytes 1207312 (1.1 MiB)`);
                        output.push(`        RX errors 0  dropped 0  overruns 0  frame 0`);
                        output.push(`        TX packets 6145  bytes 977581 (954.6 KiB)`);
                        output.push(`        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0`);
                    }
                    
                    return output.join('\n');
                } else {
                    // Configurar interface
                    if (currentState.currentUser !== 'root') {
                        return `SIOCSIFADDR: Operation not permitted\nSIOCSIFFLAGS: Operation not permitted`;
                    }
                    
                    // Procurar endereço IP
                    let ipAddress = null;
                    let netmask = null;
                    
                    for (let i = 1; i < args.length; i++) {
                        if (args[i] === 'up' || args[i] === 'down') {
                            currentState.networkInterfaces[iface].status = args[i];
                        } else if (/^\d+\.\d+\.\d+\.\d+$/.test(args[i])) {
                            ipAddress = args[i];
                        } else if (args[i] === 'netmask' && i + 1 < args.length) {
                            netmask = args[i + 1];
                            i++;
                        }
                    }
                    
                    if (ipAddress) {
                        currentState.networkInterfaces[iface].address = ipAddress;
                    }
                    
                    if (netmask) {
                        currentState.networkInterfaces[iface].netmask = netmask;
                    }
                    
                    // Atualizar arquivo interfaces
                    if (ipAddress) {
                        updateInterfacesFile(iface, ipAddress, netmaskToCIDR(netmask || '255.255.255.0'));
                    }
                    
                    return '';
                }
            }
        }

        function cmdUname(args) {
            if (args.length === 0) {
                return 'Linux';
            }
            
            if (args[0] === '-a' || args[0] === '--all') {
                return `Linux ${currentState.hostname} ${currentState.kernel.version} #1 SMP PREEMPT Debian 6.1.55-1 (2023-09-29) x86_64 GNU/Linux`;
            } else if (args[0] === '-s' || args[0] === '--kernel-name') {
                return 'Linux';
            } else if (args[0] === '-n' || args[0] === '--nodename') {
                return currentState.hostname;
            } else if (args[0] === '-r' || args[0] === '--kernel-release') {
                return currentState.kernel.version;
            } else if (args[0] === '-v' || args[0] === '--kernel-version') {
                return '#1 SMP PREEMPT Debian 6.1.55-1 (2023-09-29)';
            } else if (args[0] === '-m' || args[0] === '--machine') {
                return 'x86_64';
            } else if (args[0] === '-p' || args[0] === '--processor') {
                return 'unknown';
            } else if (args[0] === '-i' || args[0] === '--hardware-platform') {
                return 'unknown';
            } else if (args[0] === '-o' || args[0] === '--operating-system') {
                return 'GNU/Linux';
            } else {
                return `uname: opção inválida -- '${args[0].replace(/^-+/, '')}'\nTente 'uname --help' para mais informações.`;
            }
        }

        function cmdDf(args) {
            let humanReadable = false;
            let inodes = false;
            let typeFilter = null;
            
            // Processar opções
            args = args.filter(arg => {
                if (arg === '-h' || arg === '--human-readable') {
                    humanReadable = true;
                    return false;
                } else if (arg === '-i' || arg === '--inodes') {
                    inodes = true;
                    return false;
                } else if (arg === '-T' || arg === '--print-type') {
                    typeFilter = true;
                    return false;
                } else if (arg.startsWith('-t') && arg.length > 2) {
                    typeFilter = arg.substring(2);
                    return false;
                }
                return true;
            });
            
            const mountPoints = [
                { fs: '/dev/sda3', type: 'ext4', size: 47761256, used: 4668168, avail: 40566324, usePercent: 11, mountPoint: '/' },
                { fs: '/dev/sda1', type: 'ext4', size: 516040, used: 119744, avail: 367280, usePercent: 25, mountPoint: '/boot' },
                { fs: 'tmpfs', type: 'tmpfs', size: 1020152, used: 0, avail: 1020152, usePercent: 0, mountPoint: '/run' },
                { fs: 'tmpfs', type: 'tmpfs', size: 2050300, used: 0, avail: 2050300, usePercent: 0, mountPoint: '/dev/shm' },
                { fs: 'tmpfs', type: 'tmpfs', size: 5120, used: 4, avail: 5116, usePercent: 1, mountPoint: '/run/lock' },
                { fs: '/dev/sda2', type: 'swap', size: 4194304, used: 0, avail: 4194304, usePercent: 0, mountPoint: '[SWAP]' }
            ];
            
            let output = [];
            
            if (inodes) {
                output.push('Sistema de arquivos     Inodes IUsados ILivres IUso% Montado em');
                output.push('udev                    510075    408  509667    1% /dev');
                output.push('tmpfs                   512575    573  512002    1% /run');
                output.push('/dev/sda3               3055616  230371 2825245    8% /');
                output.push('tmpfs                   512575      1  512574    1% /dev/shm');
                output.push('tmpfs                   512575     16  512559    1% /run/lock');
                output.push('/dev/sda1                65536    322   65214    1% /boot');
            } else {
                if (typeFilter === true) {
                    output.push('Sistema de arquivos    Tipo     Blocos de 1K   Usado Disponível Uso% Montado em');
                } else {
                    output.push('Sistema de arquivos    Blocos de 1K   Usado Disponível Uso% Montado em');
                }
                
                mountPoints.forEach(mp => {
                    if (typeFilter && typeFilter !== true && mp.type !== typeFilter) {
                        return;
                    }
                    
                    if (mp.mountPoint === '[SWAP]' && !args.includes('-a')) {
                        return; // Não mostrar swap por padrão
                    }
                    
                    let line;
                    
                    if (typeFilter === true) {
                        if (humanReadable) {
                            line = `${mp.fs.padEnd(20)} ${mp.type.padEnd(8)} ${humanSize(mp.size * 1024).padStart(8)} ${humanSize(mp.used * 1024).padStart(8)} ${humanSize(mp.avail * 1024).padStart(8)} ${mp.usePercent.toString().padStart(3)}% ${mp.mountPoint}`;
                        } else {
                            line = `${mp.fs.padEnd(20)} ${mp.type.padEnd(8)} ${mp.size.toString().padStart(14)} ${mp.used.toString().padStart(8)} ${mp.avail.toString().padStart(10)} ${mp.usePercent.toString().padStart(3)}% ${mp.mountPoint}`;
                        }
                    } else {
                        if (humanReadable) {
                            line = `${mp.fs.padEnd(20)} ${humanSize(mp.size * 1024).padStart(14)} ${humanSize(mp.used * 1024).padStart(8)} ${humanSize(mp.avail * 1024).padStart(10)} ${mp.usePercent.toString().padStart(3)}% ${mp.mountPoint}`;
                        } else {
                            line = `${mp.fs.padEnd(20)} ${mp.size.toString().padStart(14)} ${mp.used.toString().padStart(8)} ${mp.avail.toString().padStart(10)} ${mp.usePercent.toString().padStart(3)}% ${mp.mountPoint}`;
                        }
                    }
                    
                    output.push(line);
                });
            }
            
            return output.join('\n');
        }

        function cmdDu(args) {
            let humanReadable = false;
            let summarize = false;
            let maxDepth = -1;
            
            // Processar opções
            args = args.filter(arg => {
                if (arg === '-h' || arg === '--human-readable') {
                    humanReadable = true;
                    return false;
                } else if (arg === '-s' || arg === '--summarize') {
                    summarize = true;
                    return false;
                } else if (arg.startsWith('--max-depth=')) {
                    maxDepth = parseInt(arg.split('=')[1]);
                    return false;
                }
                return true;
            });
            
            const path = args.length > 0 ? resolvePath(args[0]) : ttys[currentState.currentTTY].currentDir;
            const targetDir = getDirectoryContents(path);
            
            if (!targetDir) {
                return `du: não foi possível acessar '${path}': Arquivo ou diretório não encontrado`;
            }
            
            if (targetDir.type !== 'd') {
                const size = targetDir.content ? targetDir.content.length : 0;
                return humanReadable ? `${humanSize(size)}\t${path}` : `${Math.ceil(size / 1024)}\t${path}`;
            }
            
            // Função recursiva para calcular tamanho
            function calculateSize(dir, currentPath, depth) {
                let totalSize = 0;
                let output = [];
                
                // Calcular tamanho do diretório atual
                for (const [name, item] of Object.entries(dir.content)) {
                    const itemPath = `${currentPath}/${name}`;
                    
                    if (item.type === 'd') {
                        const result = calculateSize(item, itemPath, depth + 1);
                        totalSize += result.size;
                        
                        if (!summarize && (maxDepth === -1 || depth + 1 <= maxDepth)) {
                            output = output.concat(result.output);
                        }
                    } else {
                        const size = item.content ? item.content.length : 0;
                        totalSize += size;
                    }
                }
                
                // Adicionar entrada para este diretório
                if (maxDepth === -1 || depth <= maxDepth) {
                    const sizeKB = Math.ceil(totalSize / 1024);
                    const sizeStr = humanReadable ? humanSize(totalSize) : sizeKB.toString();
                    output.push(`${sizeStr}\t${currentPath}`);
                }
                
                return { size: totalSize, output };
            }
            
            const result = calculateSize(targetDir, path, 0);
            
            // Ordenar por caminho
            result.output.sort((a, b) => {
                const pathA = a.split('\t')[1];
                const pathB = b.split('\t')[1];
                return pathA.localeCompare(pathB);
            });
            
            return result.output.join('\n');
        }

        function cmdPs(args) {
            let showAll = false;
            let forest = false;
            let fullFormat = false;
            
            // Processar opções
            args.forEach(arg => {
                if (arg === '-a' || arg === 'a') {
                    showAll = true;
                } else if (arg === '-f' || arg === 'f') {
                    fullFormat = true;
                } else if (arg === '--forest') {
                    forest = true;
                } else if (arg === '-ef') {
                    showAll = true;
                    fullFormat = true;
                } else if (arg === '-aux') {
                    showAll = true;
                    fullFormat = true;
                }
            });
            
            // Processos simulados
            const processes = [
                { pid: 1, ppid: 0, user: 'root', cmd: 'systemd', args: 'init', time: '00:01', cpu: 0.0, mem: 0.1, stat: 'Ss', tty: '?', start: 'Jun01' },
                { pid: 2, ppid: 0, user: 'root', cmd: 'kthreadd', args: '', time: '00:00', cpu: 0.0, mem: 0.0, stat: 'S', tty: '?', start: 'Jun01' },
                { pid: 3, ppid: 2, user: 'root', cmd: 'rcu_gp', args: '', time: '00:00', cpu: 0.0, mem: 0.0, stat: 'I', tty: '?', start: 'Jun01' },
                { pid: 7, ppid: 2, user: 'root', cmd: 'kworker/0:0H', args: '', time: '00:00', cpu: 0.0, mem: 0.0, stat: 'I', tty: '?', start: 'Jun01' },
                { pid: 9, ppid: 2, user: 'root', cmd: 'mm_percpu_wq', args: '', time: '00:00', cpu: 0.0, mem: 0.0, stat: 'S', tty: '?', start: 'Jun01' },
                { pid: 10, ppid: 2, user: 'root', cmd: 'ksoftirqd/0', args: '', time: '00:00', cpu: 0.0, mem: 0.0, stat: 'S', tty: '?', start: 'Jun01' },
                { pid: 11, ppid: 2, user: 'root', cmd: 'rcu_sched', args: '', time: '00:00', cpu: 0.0, mem: 0.0, stat: 'I', tty: '?', start: 'Jun01' },
                { pid: 12, ppid: 2, user: 'root', cmd: 'migration/0', args: '', time: '00:00', cpu: 0.0, mem: 0.0, stat: 'S', tty: '?', start: 'Jun01' },
                { pid: 13, ppid: 2, user: 'root', cmd: 'cpuhp/0', args: '', time: '00:00', cpu: 0.0, mem: 0.0, stat: 'S', tty: '?', start: 'Jun01' },
                { pid: 15, ppid: 2, user: 'root', cmd: 'kdevtmpfs', args: '', time: '00:00', cpu: 0.0, mem: 0.0, stat: 'S', tty: '?', start: 'Jun01' },
                { pid: 16, ppid: 2, user: 'root', cmd: 'netns', args: '', time: '00:00', cpu: 0.0, mem: 0.0, stat: 'S', tty: '?', start: 'Jun01' },
                { pid: 17, ppid: 2, user: 'root', cmd: 'kauditd', args: '', time: '00:00', cpu: 0.0, mem: 0.0, stat: 'S', tty: '?', start: 'Jun01' },
                { pid: 18, ppid: 2, user: 'root', cmd: 'khungtaskd', args: '', time: '00:00', cpu: 0.0, mem: 0.0, stat: 'S', tty: '?', start: 'Jun01' },
                { pid: 19, ppid: 2, user: 'root', cmd: 'oom_reaper', args: '', time: '00:00', cpu: 0.0, mem: 0.0, stat: 'S', tty: '?', start: 'Jun01' },
                { pid: 20, ppid: 2, user: 'root', cmd: 'writeback', args: '', time: '00:00', cpu: 0.0, mem: 0.0, stat: 'S', tty: '?', start: 'Jun01' },
                { pid: 21, ppid: 2, user: 'root', cmd: 'kcompactd0', args: '', time: '00:00', cpu: 0.0, mem: 0.0, stat: 'S', tty: '?', start: 'Jun01' },
                { pid: 22, ppid: 2, user: 'root', cmd: 'ksmd', args: '', time: '00:00', cpu: 0.0, mem: 0.0, stat: 'S', tty: '?', start: 'Jun01' },
                { pid: 23, ppid: 2, user: 'root', cmd: 'khugepaged', args: '', time: '00:00', cpu: 0.0, mem: 0.0, stat: 'S', tty: '?', start: 'Jun01' },
                { pid: 77, ppid: 1, user: 'root', cmd: 'systemd-journald', args: '', time: '00:00', cpu: 0.0, mem: 0.1, stat: 'Ss', tty: '?', start: 'Jun01' },
                { pid: 90, ppid: 1, user: 'root', cmd: 'systemd-udevd', args: '', time: '00:00', cpu: 0.0, mem: 0.1, stat: 'Ss', tty: '?', start: 'Jun01' },
                { pid: 351, ppid: 1, user: 'root', cmd: 'cron', args: '-f', time: '00:00', cpu: 0.0, mem: 0.0, stat: 'Ss', tty: '?', start: 'Jun01' },
                { pid: 352, ppid: 1, user: 'root', cmd: 'rsyslogd', args: '-n', time: '00:00', cpu: 0.0, mem: 0.0, stat: 'Ss', tty: '?', start: 'Jun01' },
                { pid: 354, ppid: 1, user: 'root', cmd: 'sshd', args: '', time: '00:00', cpu: 0.0, mem: 0.1, stat: 'Ss', tty: '?', start: 'Jun01' },
                { pid: 450, ppid: 1, user: 'root', cmd: 'agetty', args: '--noclear tty1', time: '00:00', cpu: 0.0, mem: 0.0, stat: 'Ss+', tty: 'tty1', start: 'Jun01' },
                { pid: 451, ppid: 1, user: 'root', cmd: 'agetty', args: '--keep-baud 115200,38400,9600 tty2', time: '00:00', cpu: 0.0, mem: 0.0, stat: 'Ss+', tty: 'tty2', start: 'Jun01' },
                { pid: 452, ppid: 1, user: 'root', cmd: 'agetty', args: '--keep-baud 115200,38400,9600 tty3', time: '00:00', cpu: 0.0, mem: 0.0, stat: 'Ss+', tty: 'tty3', start: 'Jun01' },
                { pid: 453, ppid: 1, user: 'root', cmd: 'agetty', args: '--keep-baud 115200,38400,9600 tty4', time: '00:00', cpu: 0.0, mem: 0.0, stat: 'Ss+', tty: 'tty4', start: 'Jun01' },
                { pid: 454, ppid: 1, user: 'root', cmd: 'agetty', args: '--keep-baud 115200,38400,9600 tty5', time: '00:00', cpu: 0.0, mem: 0.0, stat: 'Ss+', tty: 'tty5', start: 'Jun01' },
                { pid: 455, ppid: 1, user: 'root', cmd: 'agetty', args: '--keep-baud 115200,38400,9600 tty6', time: '00:00', cpu: 0.0, mem: 0.0, stat: 'Ss+', tty: 'tty6', start: 'Jun01' },
                { pid: 500, ppid: 354, user: currentState.currentUser, cmd: 'sshd', args: currentState.currentUser, time: '00:00', cpu: 0.0, mem: 0.2, stat: 'Ss', tty: `tty${currentState.currentTTY}`, start: 'Jun01' },
                { pid: 501, ppid: 500, user: currentState.currentUser, cmd: 'bash', args: '', time: '00:00', cpu: 0.0, mem: 0.1, stat: 'Ss', tty: `tty${currentState.currentTTY}`, start: 'Jun01' },
                { pid: 789, ppid: 501, user: currentState.currentUser, cmd: 'ps', args: args.join(' '), time: '00:00', cpu: 0.0, mem: 0.0, stat: 'R+', tty: `tty${currentState.currentTTY}`, start: 'Jun01' }
            ];
            
            let output = [];
            
            if (fullFormat) {
                output.push('UID        PID  PPID  C STIME TTY          TIME CMD');
                
                processes.forEach(proc => {
                    if (!showAll && proc.tty === '?' && proc.user !== currentState.currentUser) {
                        return;
                    }
                    
                    const line = `${proc.user.padEnd(9)} ${proc.pid.toString().padStart(5)} ${proc.ppid.toString().padStart(5)} ${Math.floor(proc.cpu).toString()} ${proc.start} ${proc.tty.padEnd(12)} ${proc.time} ${proc.cmd}${proc.args ? ' ' + proc.args : ''}`;
                    output.push(line);
                });
            } else {
                output.push('  PID TTY          TIME CMD');
                
                processes.forEach(proc => {
                    if (!showAll && (proc.tty === '?' || proc.user !== currentState.currentUser)) {
                        return;
                    }
                    
                    const line = `${proc.pid.toString().padStart(5)} ${proc.tty.padEnd(12)} ${proc.time} ${proc.cmd}`;
                    output.push(line);
                });
            }
            
            return output.join('\n');
        }

        function cmdTop() {
            // Simulação simplificada do top
            const uptime = Math.floor((new Date().getTime() - currentState.bootTime) / 1000);
            const updays = Math.floor(uptime / 86400);
            const uphours = Math.floor((uptime % 86400) / 3600);
            const upmins = Math.floor((uptime % 3600) / 60);
            
            const output = [
                `top - ${new Date().toTimeString().slice(0, 8)} up ${updays ? updays + ' days, ' : ''}${uphours}:${upmins.toString().padStart(2, '0')},  1 user,  load average: 0.00, 0.00, 0.00`,
                'Tasks:  32 total,   1 running,  31 sleeping,   0 stopped,   0 zombie',
                '%Cpu(s):  0.7 us,  0.3 sy,  0.0 ni, 98.9 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st',
                'MiB Mem :   4096.0 total,   3514.7 free,    271.7 used,    309.6 buff/cache',
                'MiB Swap:   4096.0 total,   4096.0 free,      0.0 used.   3662.8 avail Mem',
                '',
                '    PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND',
                '      1 root      20   0  168804  11768   8896 S   0.0   0.1   0:01.38 systemd',
                '      2 root      20   0       0      0      0 S   0.0   0.0   0:00.00 kthreadd',
                '      3 root       0 -20       0      0      0 I   0.0   0.0   0:00.00 rcu_gp',
                '      7 root       0 -20       0      0      0 I   0.0   0.0   0:00.00 kworker/0:0H',
                '      9 root       0 -20       0      0      0 I   0.0   0.0   0:00.00 mm_percpu_wq',
                '     10 root      20   0       0      0      0 S   0.0   0.0   0:00.00 ksoftirqd/0',
                '     11 root      20   0       0      0      0 I   0.0   0.0   0:00.00 rcu_sched',
                '     77 root      20   0   16236   7724   7092 S   0.0   0.1   0:00.17 systemd-journald',
                '     90 root      20   0   14624   5296   4584 S   0.0   0.1   0:00.05 systemd-udevd',
                '    351 root      20   0    9168   3512   3024 S   0.0   0.0   0:00.00 cron',
                '    352 root      20   0   32116   3960   3220 S   0.0   0.0   0:00.00 rsyslogd',
                '    354 root      20   0   15608   6816   5872 S   0.0   0.1   0:00.00 sshd',
                '    450 root      20   0    7620   3396   2988 S+  0.0   0.0   0:00.00 agetty',
                '    500 root      20   0   15608   6816   5872 S   0.0   0.1   0:00.00 sshd',
                `    501 ${currentState.currentUser.padEnd(8)} 20   0   15312   6320   5472 S   0.0   0.1   0:00.00 bash`,
                `    789 ${currentState.currentUser.padEnd(8)} 20   0    9628   3764   3220 R   0.0   0.0   0:00.00 top`
            ];
            
            return output.join('\n');
        }

        function cmdKill(args) {
            if (args.length === 0) {
                return 'kill: uso: kill [-s sinal] pid...';
            }
            
            let signal = 15; // SIGTERM por padrão
            
            // Verificar por opção de sinal
            if (args[0].startsWith('-')) {
                const signalArg = args.shift();
                
                if (signalArg === '-l') {
                    return ' 1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL       5) SIGTRAP\n' +
                           ' 6) SIGABRT      7) SIGBUS       8) SIGFPE       9) SIGKILL     10) SIGUSR1\n' +
                           '11) SIGSEGV     12) SIGUSR2     13) SIGPIPE     14) SIGALRM     15) SIGTERM\n' +
                           '16) SIGSTKFLT   17) SIGCHLD     18) SIGCONT     19) SIGSTOP     20) SIGTSTP\n' +
                           '21) SIGTTIN     22) SIGTTOU     23) SIGURG      24) SIGXCPU     25) SIGXFSZ\n' +
                           '26) SIGVTALRM   27) SIGPROF     28) SIGWINCH    29) SIGIO       30) SIGPWR\n' +
                           '31) SIGSYS      34) SIGRTMIN    35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+3\n' +
                           '38) SIGRTMIN+4  39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8\n' +
                           '43) SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13\n' +
                           '48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-12\n' +
                           '53) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-7\n' +
                           '58) SIGRTMAX-6  59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2\n' +
                           '63) SIGRTMAX-1  64) SIGRTMAX';
                }
                
                if (signalArg.startsWith('-SIG')) {
                    const signalName = signalArg.substring(1);
                    
                    if (signalName === 'SIGTERM') {
                        signal = 15;
                    } else if (signalName === 'SIGKILL') {
                        signal = 9;
                    } else if (signalName === 'SIGHUP') {
                        signal = 1;
                    } else if (signalName === 'SIGINT') {
                        signal = 2;
                    } else {
                        return `kill: ${signalName}: sinal inválido`;
                    }
                } else {
                    signal = parseInt(signalArg.substring(1));
                    
                    if (isNaN(signal) || signal < 1 || signal > 64) {
                        return `kill: ${signalArg}: sinal inválido`;
                    }
                }
            }
            
            // Processar PIDs
            let errors = [];
            
            for (const pidArg of args) {
                const pid = parseInt(pidArg);
                
                if (isNaN(pid)) {
                    errors.push(`kill: ${pidArg}: argumento inválido`);
                    continue;
                }
                
                // Simular resultado
                if (pid <= 0 || pid >= 1000) {
                    errors.push(`kill: (${pid}) - Operação não permitida`);
                } else if (pid < 100 && currentState.currentUser !== 'root') {
                    errors.push(`kill: (${pid}) - Operação não permitida`);
                }
            }
            
            return errors.join('\n');
        }

        function cmdFree(args) {
            let humanReadable = false;
            
            // Processar opções
            args.forEach(arg => {
                if (arg === '-h' || arg === '--human') {
                    humanReadable = true;
                }
            });
            
            if (humanReadable) {
                return '              total        used        free      shared  buff/cache   available\n' +
                       'Mem:           4.0G        0.3G        3.4G        0.0G        0.3G        3.6G\n' +
                       'Swap:          4.0G        0.0G        4.0G';
            } else {
                return '              total        used        free      shared  buff/cache   available\n' +
                       'Mem:        4194304      279552     3599360          16      315392     3750912\n' +
                       'Swap:       4194304           0     4194304';
            }
        }

        function cmdMan(args) {
            if (args.length === 0) {
                return 'Qual página do manual você quer?\nPara instruções de uso, tente: man man';
            }
            
            const command = args[0];
            
            return `Nenhuma entrada de manual para ${command}\n\nVocê pode incluir páginas de manual do sistema instalando o pacote manpages.`;
        }

        function cmdSudo(args) {
            if (args.length === 0) {
                return 'sudo: nenhum comando especificado';
            }
            
            // Verificar se o usuário pode usar sudo
            if (currentState.currentUser !== 'root') {
                const userInfo = currentState.users[currentState.currentUser];
                
                if (!userInfo || !userInfo.groups.includes('sudo')) {
                    return `${currentState.currentUser} não está no arquivo sudoers. Este incidente será relatado.`;
                }
            }
            
            // Executar comando como root
            const originalUser = currentState.currentUser;
            currentState.currentUser = 'root';
            
            const command = args[0];
            const commandArgs = args.slice(1);
            
            let output;
            
            try {
                // Executar comando com os argumentos
                const commandLine = [command, ...commandArgs].join(' ');
                
                // Simular a execução do comando
                let tempOutputLines = [];
                const addTempOutput = (text) => {
                    if (text) {
                        tempOutputLines.push(text);
                    }
                };
                
                isExecuting = true;
                
                switch (command) {
                    case 'ls':
                        addTempOutput(cmdLs(commandArgs));
                        break;
                    case 'cat':
                        addTempOutput(cmdCat(commandArgs));
                        break;
                    case 'apt':
                    case 'apt-get':
                        addTempOutput(cmdApt(commandArgs));
                        break;
                    case 'systemctl':
                        addTempOutput(cmdSystemctl(commandArgs));
                        break;
                    case 'reboot':
                        cmdReboot();
                        return null;
                    case 'poweroff':
                    case 'shutdown':
                        cmdPoweroff();
                        return null;
                    default:
                        addTempOutput(`sudo: ${command}: comando não encontrado`);
                        break;
                }
                
                output = tempOutputLines.join('\n');
            } finally {
                // Restaurar usuário original
                currentState.currentUser = originalUser;
            }
            
            return output;
        }

        function cmdSu(args) {
            const targetUser = args.length > 0 ? args[0] : 'root';
            
            if (!currentState.users[targetUser]) {
                addOutput(`su: usuário ${targetUser} não existe`, 'error');
                isExecuting = false;
                renderPrompt();
                return;
            }
            
            // Se for trocar para root ou o usuário atual já é root, não precisa de senha
            if (targetUser === 'root' && currentState.currentUser === 'root') {
                currentState.currentUser = targetUser;
                ttys[currentState.currentTTY].user = targetUser;
                ttys[currentState.currentTTY].currentDir = targetUser === 'root' ? '/root' : `/home/${targetUser}`;
                
                addOutput('');
                isExecuting = false;
                renderPrompt();
                return;
            }
            
            // Pedir senha
            loadingElement.style.display = 'flex';
            loadingTextElement.textContent = 'Senha: ';
            
            let password = '';
            
            const passwordListener = function(e) {
                if (e.key === 'Enter') {
                    document.removeEventListener('keydown', passwordListener);
                    
                    if (currentState.users[targetUser].password === password || currentState.currentUser === 'root') {
                        loadingElement.style.display = 'none';
                        
                        currentState.currentUser = targetUser;
                        ttys[currentState.currentTTY].user = targetUser;
                        ttys[currentState.currentTTY].currentDir = targetUser === 'root' ? '/root' : `/home/${targetUser}`;
                        
                        addOutput('');
                        isExecuting = false;
                        renderPrompt();
                    } else {
                        loadingElement.style.display = 'none';
                        addOutput('su: Falha na autenticação', 'error');
                        isExecuting = false;
                        renderPrompt();
                    }
                } else if (e.key === 'Escape') {
                    document.removeEventListener('keydown', passwordListener);
                    loadingElement.style.display = 'none';
                    addOutput('');
                    isExecuting = false;
                    renderPrompt();
                } else if (e.key === 'Backspace') {
                    if (password.length > 0) {
                        password = password.slice(0, -1);
                    }
                } else if (e.key.length === 1) {
                    password += e.key;
                }
            };
            
            document.addEventListener('keydown', passwordListener);
        }

        function cmdPasswd(args) {
            const targetUser = args.length > 0 ? args[0] : currentState.currentUser;
            
            // Verificar permissões
            if (targetUser !== currentState.currentUser && currentState.currentUser !== 'root') {
                addOutput('passwd: você não pode alterar a senha de ' + targetUser, 'error');
                isExecuting = false;
                renderPrompt();
                return;
            }
            
            if (!currentState.users[targetUser]) {
                addOutput(`passwd: usuário '${targetUser}' não existe`, 'error');
                isExecuting = false;
                renderPrompt();
                return;
            }
            
            // Pedir senha atual se não for root
            let stage = currentState.currentUser === 'root' && targetUser !== currentState.currentUser ? 'new' : 'current';
            let currentPassword = '';
            let newPassword = '';
            let confirmPassword = '';
            
            loadingElement.style.display = 'flex';
            
            if (stage === 'current') {
                loadingTextElement.textContent = `Senha atual para ${targetUser}: `;
            } else {
                loadingTextElement.textContent = `Nova senha para ${targetUser}: `;
            }
            
            const passwordListener = function(e) {
                if (e.key === 'Enter') {
                    if (stage === 'current') {
                        if (currentState.users[targetUser].password === currentPassword) {
                            stage = 'new';
                            loadingTextElement.textContent = `Nova senha para ${targetUser}: `;
                        } else {
                            document.removeEventListener('keydown', passwordListener);
                            loadingElement.style.display = 'none';
                            addOutput('passwd: Falha na autenticação', 'error');
                            isExecuting = false;
                            renderPrompt();
                        }
                    } else if (stage === 'new') {
                        if (newPassword.length < 4) {
                            loadingTextElement.textContent = 'Senha muito curta. Nova senha: ';
                            newPassword = '';
                        } else {
                            stage = 'confirm';
                            loadingTextElement.textContent = 'Redigite a nova senha: ';
                        }
                    } else if (stage === 'confirm') {
                        if (newPassword === confirmPassword) {
                            document.removeEventListener('keydown', passwordListener);
                            loadingElement.style.display = 'none';
                            
                            // Atualizar senha
                            currentState.users[targetUser].password = newPassword;
                            
                            addOutput('passwd: senha atualizada com sucesso');
                            isExecuting = false;
                            renderPrompt();
                        } else {
                            loadingTextElement.textContent = 'As senhas não coincidem. Nova senha: ';
                            stage = 'new';
                            newPassword = '';
                            confirmPassword = '';
                        }
                    }
                } else if (e.key === 'Escape') {
                    document.removeEventListener('keydown', passwordListener);
                    loadingElement.style.display = 'none';
                    addOutput('passwd: Operação cancelada', 'error');
                    isExecuting = false;
                    renderPrompt();
                } else if (e.key === 'Backspace') {
                    if (stage === 'current' && currentPassword.length > 0) {
                        currentPassword = currentPassword.slice(0, -1);
                    } else if (stage === 'new' && newPassword.length > 0) {
                        newPassword = newPassword.slice(0, -1);
                    } else if (stage === 'confirm' && confirmPassword.length > 0) {
                        confirmPassword = confirmPassword.slice(0, -1);
                    }
                } else if (e.key.length === 1) {
                    if (stage === 'current') {
                        currentPassword += e.key;
                    } else if (stage === 'new') {
                        newPassword += e.key;
                    } else if (stage === 'confirm') {
                        confirmPassword += e.key;
                    }
                }
            };
            
            document.addEventListener('keydown', passwordListener);
        }

        function cmdNano(args) {
            if (args.length === 0) {
                // Criar arquivo temporário
                const tempName = `nano_temp_${Date.now()}.txt`;
                openEditor('', `/tmp/${tempName}`);
                return;
            }
            
            const filePath = resolvePath(args[0]);
            const file = getDirectoryContents(filePath);
            
            if (file && file.type === 'd') {
                addOutput(`nano: ${args[0]} é um diretório`, 'error');
                isExecuting = false;
                renderPrompt();
                return;
            }
            
            const content = file ? file.content : '';
            openEditor(content, filePath);
        }

        function cmdVim(args) {
            if (args.length === 0) {
                addOutput('vim: nenhum arquivo especificado');
                isExecuting = false;
                renderPrompt();
                return;
            }
            
            const filePath = resolvePath(args[0]);
            const file = getDirectoryContents(filePath);
            
            if (file && file.type === 'd') {
                addOutput(`vim: ${args[0]} é um diretório`, 'error');
                isExecuting = false;
                renderPrompt();
                return;
            }
            
            const content = file ? file.content : '';
            openEditor(content, filePath);
        }

        function openEditor(content, filePath) {
            editorContainer.style.display = 'flex';
            editorContent.value = content;
            editorHeader.textContent = `Editando: ${filePath}`;
            editorStatus.textContent = 'Pressione Ctrl+O para salvar, Ctrl+X para sair';
            editorPosition.textContent = 'Linha: 1, Coluna: 1';
            
            activeEditor = {
                filePath: filePath,
                content: content,
                saved: true
            };
            
            setTimeout(() => {
                editorContent.focus();
            }, 100);
        }

        function updateEditorPosition() {
            if (!activeEditor) return;
            
            const text = editorContent.value;
            const cursorPos = editorContent.selectionStart;
            
            // Calcular linha e coluna
            let line = 1;
            let col = 1;
            
            for (let i = 0; i < cursorPos; i++) {
                if (text[i] === '\n') {
                    line++;
                    col = 1;
                } else {
                    col++;
                }
            }
            
            editorPosition.textContent = `Linha: ${line}, Coluna: ${col}`;
        }

        function closeEditor() {
            if (editorContent.value !== activeEditor.content) {
                const confirmed = confirm('Arquivo foi modificado. Salvar alterações?');
                
                if (confirmed) {
                    saveEditorContent();
                }
            }
            
            editorContainer.style.display = 'none';
            activeEditor = null;
            
            isExecuting = false;
            renderPrompt();
        }

        function saveEditorContent() {
            const filePath = activeEditor.filePath;
            const content = editorContent.value;
            
            const parentDir = getParentDirectory(filePath);
            const fileName = filePath.split('/').pop();
            
            if (!parentDir) {
                // Criar diretórios pais
                const parts = filePath.split('/').filter(p => p);
                let currentPath = '';
                
                for (let i = 0; i < parts.length - 1; i++) {
                    currentPath += '/' + parts[i];
                    
                    const currentDir = getDirectoryContents(currentPath);
                    
                    if (!currentDir) {
                        // Verificar se o pai existe
                        const parentPath = currentPath.substring(0, currentPath.lastIndexOf('/'));
                        const parentDir = getDirectoryContents(parentPath);
                        
                        if (!parentDir) {
                            alert(`Não foi possível salvar: diretório ${parentPath} não existe`);
                            return;
                        }
                        
                        // Criar diretório
                        parentDir.content[parts[i]] = {
                            type: 'd',
                            permissions: 'drwxr-xr-x',
                            owner: currentState.currentUser,
                            group: currentState.currentUser,
                            content: {},
                            date: getCurrentDate()
                        };
                    }
                }
            }
            
            // Atualizar ou criar arquivo
            const updatedParentDir = getParentDirectory(filePath);
            
            if (updatedParentDir) {
                if (updatedParentDir.content[fileName]) {
                    updatedParentDir.content[fileName].content = content;
                    updatedParentDir.content[fileName].date = getCurrentDate();
                } else {
                    updatedParentDir.content[fileName] = {
                        type: '-',
                        permissions: '-rw-r--r--',
                        owner: currentState.currentUser,
                        group: currentState.currentUser,
                        content: content,
                        date: getCurrentDate()
                    };
                }
                
                activeEditor.content = content;
                activeEditor.saved = true;
            }
        }

        function cmdFdisk(args) {
            if (args.length === 0) {
                return 'Uso:\n' +
                       ' fdisk [opções] <disco>     alterar a tabela de partição\n' +
                       ' fdisk [opções] -l [<disco>] listar a tabela de partição\n\n' +
                       'Exibir ou manipular uma tabela de partição de disco.';
            }
            
            if (args[0] === '-l') {
                // Listar partições
                const disk = args.length > 1 ? args[1] : null;
                
                if (disk && !disk.startsWith('/dev/sd')) {
                    return `fdisk: não foi possível abrir ${disk}: Arquivo ou diretório não encontrado`;
                }
                
                if (disk && !Object.keys(currentState.disks).includes(disk.substring(5))) {
                    return `fdisk: não foi possível abrir ${disk}: Arquivo ou diretório não encontrado`;
                }
                
                let output = [];
                
                // Listar todos os discos ou o disco específico
                for (const [diskName, diskInfo] of Object.entries(currentState.disks)) {
                    if (disk && disk !== `/dev/${diskName}`) continue;
                    
                    output.push(`Disco /dev/${diskName}: ${diskInfo.size}, 50 GiB, 53687091200 bytes, 104857600 setores`);
                    output.push('Unidades: setores de 1 * 512 = 512 bytes');
                    output.push('Tamanho de setor (lógico/físico): 512 bytes / 512 bytes');
                    output.push('Tamanho de E/S (mínimo/ideal): 512 bytes / 512 bytes');
                    output.push('Tipo de rótulo do disco: gpt');
                    output.push('Identificador do disco: 8B8B8066-0377-4816-A561-D92C12B8A986');
                    output.push('');
                    output.push('Dispositivo     Início       Fim   Setores Tamanho Tipo');
                    
                    for (const [partName, partInfo] of Object.entries(diskInfo.partitions)) {
                        let type = 'Linux filesystem';
                        if (partInfo.mountpoint === '[SWAP]') {
                            type = 'Linux swap';
                        } else if (partInfo.mountpoint === '/boot') {
                            type = 'EFI System';
                        }
                        
                        const start = partName === 'sda1' ? 2048 : (partName === 'sda2' ? 1026048 : 9420800);
                        const end = start + (parseInt(partInfo.size) * 2 * 1024) - 1;
                        const sectors = end - start + 1;
                        
                        output.push(`/dev/${partName}      ${start.toString().padEnd(10)} ${end.toString().padEnd(8)} ${sectors.toString().padEnd(8)} ${partInfo.size}  ${type}`);
                    }
                    
                    output.push('');
                }
                
                return output.join('\n');
            } else {
                // Modo interativo (simplificado)
                return 'Comando fdisk em modo interativo não disponível na simulação. Use a opção -l para listar partições.';
            }
        }

        function cmdMount(args) {
            if (args.length === 0) {
                // Listar montagens
                const mounts = [
                    'sysfs on /sys type sysfs (rw,nosuid,nodev,noexec,relatime)',
                    'proc on /proc type proc (rw,nosuid,nodev,noexec,relatime)',
                    'udev on /dev type devtmpfs (rw,nosuid,relatime,size=1967128k,nr_inodes=491782,mode=755)',
                    'devpts on /dev/pts type devpts (rw,nosuid,noexec,relatime,gid=5,mode=620,ptmxmode=000)',
                    'tmpfs on /run type tmpfs (rw,nosuid,noexec,relatime,size=395508k,mode=755)',
                    '/dev/sda3 on / type ext4 (rw,relatime,errors=remount-ro)',
                    '/dev/sda1 on /boot type ext4 (rw,relatime)',
                    'tmpfs on /dev/shm type tmpfs (rw,nosuid,nodev)',
                    'tmpfs on /run/lock type tmpfs (rw,nosuid,nodev,noexec,relatime,size=5120k)',
                    'tmpfs on /sys/fs/cgroup type tmpfs (ro,nosuid,nodev,noexec,mode=755)',
                    'cgroup2 on /sys/fs/cgroup/unified type cgroup2 (rw,nosuid,nodev,noexec,relatime)',
                    'cgroup on /sys/fs/cgroup/systemd type cgroup (rw,nosuid,nodev,noexec,relatime,xattr,name=systemd)',
                    'binfmt_misc on /proc/sys/fs/binfmt_misc type binfmt_misc (rw,relatime)',
                    'tmpfs on /run/user/1000 type tmpfs (rw,nosuid,nodev,relatime,size=395504k,mode=700,uid=1000,gid=1000)'
                ];
                
                return mounts.join('\n');
            } else {
                // Montar dispositivo
                if (currentState.currentUser !== 'root') {
                    return 'mount: somente root pode fazer isso';
                }
                
                // Simplificação - não implementa montagem real
                return '';
            }
        }

        function cmdUmount(args) {
            if (args.length === 0) {
                return 'umount: nenhum ponto de montagem especificado';
            }
            
            if (currentState.currentUser !== 'root') {
                return 'umount: somente root pode fazer isso';
            }
            
            // Simplificação - não implementa desmontagem real
            return '';
        }

        function cmdSystemctl(args) {
            if (args.length === 0) {
                return 'uso: systemctl [OPÇÕES...] COMANDO [NOME...]';
            }
            
            const command = args[0];
            const serviceName = args.length > 1 ? args[1] : null;
            
            if (command === 'status') {
                if (!serviceName) {
                    return 'usage: systemctl status UNIT...\n\nExibir status das unidades.';
                }
                
                if (!currentState.services[serviceName]) {
                    return `Unit ${serviceName}.service could not be found.`;
                }
                
                const service = currentState.services[serviceName];
                const status = service.status === 'running' ? 'active (running)' : 'inactive (dead)';
                const color = service.status === 'running' ? 'success' : 'error';
                
                const since = new Date(currentState.bootTime + Math.random() * 10000);
                
                return `● ${serviceName}.service - ${serviceName.toUpperCase()} service\n` +
                       `     Loaded: loaded (/lib/systemd/system/${serviceName}.service; ${service.enabled ? 'enabled' : 'disabled'}; vendor preset: enabled)\n` +
                       `     Active: ${status} since ${since.toUTCString()}; ${Math.floor((new Date() - since) / 1000)}s ago\n` +
                       `       Docs: man:${serviceName}(8)\n` +
                       `    Process: 1234 ExecStart=/usr/sbin/${serviceName} ${serviceName === 'sshd' ? '-D' : serviceName === 'apache2' ? '-k start' : ''} (code=exited, status=0/SUCCESS)\n` +
                       `   Main PID: ${serviceName === 'sshd' ? 354 : serviceName === 'apache2' ? 355 : 356} (${serviceName})\n` +
                       `      Tasks: 1 (limit: 4684)\n` +
                       `     Memory: 3.0M\n` +
                       `        CPU: 10ms\n` +
                       `     CGroup: /system.slice/${serviceName}.service\n` +
                       `             └─${serviceName === 'sshd' ? 354 : serviceName === 'apache2' ? 355 : 356} /usr/sbin/${serviceName} ${serviceName === 'sshd' ? '-D' : serviceName === 'apache2' ? '-k start' : ''}`;
            } else if (command === 'start') {
                if (!serviceName) {
                    return 'usage: systemctl start UNIT...\n\nIniciar (ativar) uma ou mais unidades';
                }
                
                if (currentState.currentUser !== 'root') {
                    return `==== AUTHENTICATING FOR org.freedesktop.systemd1.manage-units ====\nAutenticação necessária para iniciar '${serviceName}.service'.\nAuthentication failed.`;
                }
                
                if (!currentState.services[serviceName]) {
                    return `Failed to start ${serviceName}.service: Unit ${serviceName}.service not found.`;
                }
                
                // Verificar se o serviço está instalado
                if (serviceName === 'apache2' && !currentState.installedPackages['apache2']) {
                    return `Failed to start ${serviceName}.service: Unit ${serviceName}.service not found.`;
                } else if (serviceName === 'sshd' && !currentState.installedPackages['openssh-server']) {
                    return `Failed to start ${serviceName}.service: Unit ${serviceName}.service not found.`;
                } else if (serviceName === 'mysql' && !currentState.installedPackages['mysql-server']) {
                    return `Failed to start ${serviceName}.service: Unit ${serviceName}.service not found.`;
                }
                
                currentState.services[serviceName].status = 'running';
                return '';
            } else if (command === 'stop') {
                if (!serviceName) {
                    return 'usage: systemctl stop UNIT...\n\nParar (desativar) uma ou mais unidades';
                }
                
                if (currentState.currentUser !== 'root') {
                    return `==== AUTHENTICATING FOR org.freedesktop.systemd1.manage-units ====\nAutenticação necessária para parar '${serviceName}.service'.\nAuthentication failed.`;
                }
                
                if (!currentState.services[serviceName]) {
                    return `Failed to stop ${serviceName}.service: Unit ${serviceName}.service not found.`;
                }
                
                currentState.services[serviceName].status = 'stopped';
                return '';
            } else if (command === 'restart') {
                if (!serviceName) {
                    return 'usage: systemctl restart UNIT...\n\nReiniciar uma ou mais unidades';
                }
                
                if (currentState.currentUser !== 'root') {
                    return `==== AUTHENTICATING FOR org.freedesktop.systemd1.manage-units ====\nAutenticação necessária para reiniciar '${serviceName}.service'.\nAuthentication failed.`;
                }
                
                if (!currentState.services[serviceName]) {
                    return `Failed to restart ${serviceName}.service: Unit ${serviceName}.service not found.`;
                }
                
                // Verificar se o serviço está instalado
                if (serviceName === 'apache2' && !currentState.installedPackages['apache2']) {
                    return `Failed to restart ${serviceName}.service: Unit ${serviceName}.service not found.`;
                } else if (serviceName === 'sshd' && !currentState.installedPackages['openssh-server']) {
                    return `Failed to restart ${serviceName}.service: Unit ${serviceName}.service not found.`;
                }
                
                currentState.services[serviceName].status = 'running';
                return '';
            } else if (command === 'enable') {
                if (!serviceName) {
                    return 'usage: systemctl enable UNIT...\n\nHabilitar uma ou mais unidades';
                }
                
                if (currentState.currentUser !== 'root') {
                    return `==== AUTHENTICATING FOR org.freedesktop.systemd1.manage-unit-files ====\nAutenticação necessária para habilitar '${serviceName}.service'.\nAuthentication failed.`;
                }
                
                if (!currentState.services[serviceName]) {
                    return `Failed to enable ${serviceName}.service: Unit ${serviceName}.service not found.`;
                }
                
                currentState.services[serviceName].enabled = true;
                return `Created symlink /etc/systemd/system/multi-user.target.wants/${serviceName}.service → /lib/systemd/system/${serviceName}.service.`;
            } else if (command === 'disable') {
                if (!serviceName) {
                    return 'usage: systemctl disable UNIT...\n\nDesabilitar uma ou mais unidades';
                }
                
                if (currentState.currentUser !== 'root') {
                    return `==== AUTHENTICATING FOR org.freedesktop.systemd1.manage-unit-files ====\nAutenticação necessária para desabilitar '${serviceName}.service'.\nAuthentication failed.`;
                }
                
                if (!currentState.services[serviceName]) {
                    return `Failed to disable ${serviceName}.service: Unit ${serviceName}.service not found.`;
                }
                
                currentState.services[serviceName].enabled = false;
                return `Removed /etc/systemd/system/multi-user.target.wants/${serviceName}.service.`;
            } else if (command === 'list-units' || command === 'list-unit-files') {
                // Listar unidades
                let output = [];
                
                if (command === 'list-units') {
                    output.push('UNIT                               LOAD   ACTIVE SUB     DESCRIPTION');
                    for (const [name, service] of Object.entries(currentState.services)) {
                        output.push(`${(name + '.service').padEnd(35)} loaded ${service.status === 'running' ? 'active' : 'inactive'} ${service.status === 'running' ? 'running' : 'dead'} ${name.toUpperCase()} service`);
                    }
                } else {
                    output.push('UNIT FILE                        STATE');
                    for (const [name, service] of Object.entries(currentState.services)) {
                        output.push(`${(name + '.service').padEnd(35)} ${service.enabled ? 'enabled' : 'disabled'}`);
                    }
                }
                
                return output.join('\n');
            } else {
                return `Unknown operation ${command}.`;
            }
        }

        function cmdJournalctl(args) {
            let output = [
                '-- Logs begin at Sun 2025-06-01 00:00:00 UTC, end at Sun 2025-06-01 08:30:00 UTC. --',
                'Jun 01 00:00:00 debian kernel: Linux version 6.1.0-11-amd64 (debian-kernel@lists.debian.org) (gcc-12 (Debian 12.2.0-14) 12.2.0, GNU ld (GNU Binutils for Debian) 2.40)',
                'Jun 01 00:00:00 debian kernel: Command line: BOOT_IMAGE=/vmlinuz-6.1.0-11-amd64 root=UUID=a1b2c3d4-e5f6-7890-abcd-ef1234567890 ro quiet',
                'Jun 01 00:00:00 debian kernel: x86/fpu: Supporting XSAVE feature 0x001: \'x87 floating point registers\'',
                'Jun 01 00:00:01 debian systemd[1]: Reached target System Initialization.',
                'Jun 01 00:00:01 debian systemd[1]: Started Journal Service.',
                'Jun 01 00:00:02 debian systemd-journald[77]: Received client request to flush runtime journal.',
                'Jun 01 00:00:03 debian systemd[1]: Starting System Logging Service...',
                'Jun 01 00:00:03 debian systemd[1]: Started System Logging Service.',
                'Jun 01 00:00:04 debian kernel: EXT4-fs (sda3): mounted filesystem with ordered data mode. Quota mode: none.',
                'Jun 01 00:00:04 debian kernel: input: AT Translated Set 2 keyboard as /devices/platform/i8042/serio0/input/input0'
            ];
            
            // Adicionar alguns logs específicos de serviços
            for (const [name, service] of Object.entries(currentState.services)) {
                if (service.status === 'running') {
                    output.push(`Jun 01 00:00:05 debian systemd[1]: Started ${name.toUpperCase()} service.`);
                }
            }
            
            // Filtrar por unidade
            if (args.includes('-u')) {
                const unitIndex = args.indexOf('-u');
                if (unitIndex + 1 < args.length) {
                    const unit = args[unitIndex + 1];
                    output = output.filter(line => line.includes(unit));
                }
            }
            
            // Filtrar por follow
            if (args.includes('-f') || args.includes('--follow')) {
                output.push('-- Logs begin at Sun 2025-06-01 00:00:00 UTC. --');
            }
            
            return output.join('\n');
        }

        function cmdReboot() {
            if (currentState.currentUser !== 'root') {
                addOutput('reboot: Permission denied', 'error');
                isExecuting = false;
                renderPrompt();
                return;
            }
            
            addOutput('Reiniciando sistema...');
            
            loadingElement.style.display = 'flex';
            loadingTextElement.textContent = 'Reiniciando...';
            
            setTimeout(() => {
                ttys[currentState.currentTTY].output = [];
                loadingElement.style.display = 'none';
                bootSystem();
                
                // Atualizar tempo de inicialização
                currentState.bootTime = new Date().getTime();
            }, 3000);
        }

        function cmdPoweroff() {
            if (currentState.currentUser !== 'root') {
                addOutput('poweroff: Permission denied', 'error');
                isExecuting = false;
                renderPrompt();
                return;
            }
            
            addOutput('Desligando sistema...');
            
            loadingElement.style.display = 'flex';
            loadingTextElement.textContent = 'Desligando...';
            
            setTimeout(() => {
                ttys[currentState.currentTTY].output = [];
                
                // Tela preta com mensagem
                loadingElement.style.display = 'none';
                
                addOutput('System halted.');
                addOutput('');
                addOutput('Press Enter to restart...');
                
                // Quando pressionar Enter, reiniciar
                const poweroffListener = function(e) {
                    if (e.key === 'Enter') {
                        document.removeEventListener('keydown', poweroffListener);
                        ttys[currentState.currentTTY].output = [];
                        bootSystem();
                        
                        // Atualizar tempo de inicialização
                        currentState.bootTime = new Date().getTime();
                    }
                };
                
                document.addEventListener('keydown', poweroffListener);
            }, 3000);
        }

        function cmdHostname(args) {
            if (args.length === 0) {
                return currentState.hostname;
            }
            
            if (currentState.currentUser !== 'root') {
                return 'hostname: você não tem privilégios suficientes para executar esta operação';
            }
            
            const newHostname = args[0];
            currentState.hostname = newHostname;
            
            // Atualizar arquivo hostname
            const hostnameFile = getDirectoryContents('/etc/hostname');
            if (hostnameFile) {
                hostnameFile.content = newHostname;
                hostnameFile.date = getCurrentDate();
            }
            
            return '';
        }

        function cmdHistory() {
            if (inputHistory.length === 0) {
                return '';
            }
            
            let output = [];
            
            for (let i = 0; i < inputHistory.length; i++) {
                output.push(`${i + 1}  ${inputHistory[i]}`);
            }
            
            return output.join('\n');
        }

        function cmdChmod(args) {
            if (args.length < 2) {
                return 'chmod: faltando operando\nTente \'chmod --help\' para mais informações.';
            }
            
            const mode = args[0];
            const targets = args.slice(1);
            
            let errors = [];
            
            for (const target of targets) {
                const targetPath = resolvePath(target);
                const targetFile = getDirectoryContents(targetPath);
                
                if (!targetFile) {
                    errors.push(`chmod: não foi possível acessar '${target}': Arquivo ou diretório não encontrado`);
                    continue;
                }
                
                // Verificar permissões
                if (targetFile.owner !== currentState.currentUser && currentState.currentUser !== 'root') {
                    errors.push(`chmod: não foi possível alterar permissões de '${target}': Operação não permitida`);
                    continue;
                }
                
                // Processar modo
                if (/^[0-7]{3}$/.test(mode)) {
                    // Modo numérico
                    const owner = parseInt(mode[0]);
                    const group = parseInt(mode[1]);
                    const others = parseInt(mode[2]);
                    
                    let permissions = targetFile.type;
                    
                    // Owner
                    permissions += (owner & 4) ? 'r' : '-';
                    permissions += (owner & 2) ? 'w' : '-';
                    permissions += (owner & 1) ? 'x' : '-';
                    
                    // Group
                    permissions += (group & 4) ? 'r' : '-';
                    permissions += (group & 2) ? 'w' : '-';
                    permissions += (group & 1) ? 'x' : '-';
                    
                    // Others
                    permissions += (others & 4) ? 'r' : '-';
                    permissions += (others & 2) ? 'w' : '-';
                    permissions += (others & 1) ? 'x' : '-';
                    
                    targetFile.permissions = permissions;
                } else {
                    // Modo simbólico (simplificado)
                    const add = mode.includes('+');
                    const remove = mode.includes('-');
                    
                    if (!add && !remove) {
                        errors.push(`chmod: modo inválido: '${mode}'`);
                        continue;
                    }
                    
                    const who = mode.match(/^([ugoa]+)/)?.[1] || 'a';
                    let perms = mode.match(/[+-]([rwxXst]+)/)?.[1] || '';
                    
                    // Caracteres de permissão
                    if (perms.includes('r')) {
                        if (add) {
                            if (who.includes('u') || who.includes('a')) {
                                targetFile.permissions = setCharAt(targetFile.permissions, 1, 'r');
                            }
                            if (who.includes('g') || who.includes('a')) {
                                targetFile.permissions = setCharAt(targetFile.permissions, 4, 'r');
                            }
                            if (who.includes('o') || who.includes('a')) {
                                targetFile.permissions = setCharAt(targetFile.permissions, 7, 'r');
                            }
                        } else if (remove) {
                            if (who.includes('u') || who.includes('a')) {
                                targetFile.permissions = setCharAt(targetFile.permissions, 1, '-');
                            }
                            if (who.includes('g') || who.includes('a')) {
                                targetFile.permissions = setCharAt(targetFile.permissions, 4, '-');
                            }
                            if (who.includes('o') || who.includes('a')) {
                                targetFile.permissions = setCharAt(targetFile.permissions, 7, '-');
                            }
                        }
                    }
                    
                    if (perms.includes('w')) {
                        if (add) {
                            if (who.includes('u') || who.includes('a')) {
                                targetFile.permissions = setCharAt(targetFile.permissions, 2, 'w');
                            }
                            if (who.includes('g') || who.includes('a')) {
                                targetFile.permissions = setCharAt(targetFile.permissions, 5, 'w');
                            }
                            if (who.includes('o') || who.includes('a')) {
                                targetFile.permissions = setCharAt(targetFile.permissions, 8, 'w');
                            }
                        } else if (remove) {
                            if (who.includes('u') || who.includes('a')) {
                                targetFile.permissions = setCharAt(targetFile.permissions, 2, '-');
                            }
                            if (who.includes('g') || who.includes('a')) {
                                targetFile.permissions = setCharAt(targetFile.permissions, 5, '-');
                            }
                            if (who.includes('o') || who.includes('a')) {
                                targetFile.permissions = setCharAt(targetFile.permissions, 8, '-');
                            }
                        }
                    }
                    
                    if (perms.includes('x')) {
                        if (add) {
                            if (who.includes('u') || who.includes('a')) {
                                targetFile.permissions = setCharAt(targetFile.permissions, 3, 'x');
                            }
                            if (who.includes('g') || who.includes('a')) {
                                targetFile.permissions = setCharAt(targetFile.permissions, 6, 'x');
                            }
                            if (who.includes('o') || who.includes('a')) {
                                targetFile.permissions = setCharAt(targetFile.permissions, 9, 'x');
                            }
                        } else if (remove) {
                            if (who.includes('u') || who.includes('a')) {
                                targetFile.permissions = setCharAt(targetFile.permissions, 3, '-');
                            }
                            if (who.includes('g') || who.includes('a')) {
                                targetFile.permissions = setCharAt(targetFile.permissions, 6, '-');
                            }
                            if (who.includes('o') || who.includes('a')) {
                                targetFile.permissions = setCharAt(targetFile.permissions, 9, '-');
                            }
                        }
                    }
                }
            }
            
            return errors.join('\n');
        }

        function cmdChown(args) {
            if (args.length < 2) {
                return 'chown: faltando operando\nTente \'chown --help\' para mais informações.';
            }
            
            const owner = args[0];
            const targets = args.slice(1);
            
            // Verificar se o usuário pode executar chown
            if (currentState.currentUser !== 'root') {
                return `chown: mudando proprietário de '${targets[0]}': Operação não permitida`;
            }
            
            // Verificar formato do proprietário
            let newOwner = owner;
            let newGroup = null;
            
            if (owner.includes(':')) {
                const parts = owner.split(':');
                newOwner = parts[0];
                newGroup = parts[1];
            } else if (owner.includes('.')) {
                const parts = owner.split('.');
                newOwner = parts[0];
                newGroup = parts[1];
            }
            
            // Verificar se o usuário/grupo existem
            if (newOwner && newOwner !== '' && !currentState.users[newOwner]) {
                return `chown: usuário inválido: '${newOwner}'`;
            }
            
            if (newGroup && newGroup !== '' && !currentState.groups[newGroup]) {
                return `chown: grupo inválido: '${newGroup}'`;
            }
            
            let errors = [];
            
            for (const target of targets) {
                const targetPath = resolvePath(target);
                const targetFile = getDirectoryContents(targetPath);
                
                if (!targetFile) {
                    errors.push(`chown: não foi possível acessar '${target}': Arquivo ou diretório não encontrado`);
                    continue;
                }
                
                // Atualizar proprietário
                if (newOwner && newOwner !== '') {
                    targetFile.owner = newOwner;
                }
                
                // Atualizar grupo
                if (newGroup && newGroup !== '') {
                    targetFile.group = newGroup;
                }
            }
            
            return errors.join('\n');
        }

        function cmdLn(args) {
            let symbolic = false;
            
            // Processar opções
            args = args.filter(arg => {
                if (arg === '-s' || arg === '--symbolic') {
                    symbolic = true;
                    return false;
                }
                return true;
            });
            
            if (args.length < 2) {
                return 'ln: faltando operando\nTente \'ln --help\' para mais informações.';
            }
            
            const target = args[0];
            const linkName = args[1];
            
            const targetPath = resolvePath(target);
            const linkPath = resolvePath(linkName);
            
            const targetFile = getDirectoryContents(targetPath);
            
            if (!targetFile) {
                return `ln: não foi possível acessar '${target}': Arquivo ou diretório não encontrado`;
            }
            
            const linkParent = getParentDirectory(linkPath);
            const linkFileName = linkPath.split('/').pop();
            
            if (!linkParent) {
                return `ln: não foi possível criar link '${linkName}': Caminho não encontrado`;
            }
            
            if (linkParent.content[linkFileName]) {
                return `ln: não foi possível criar link '${linkName}': Arquivo existe`;
            }
            
            if (symbolic) {
                // Link simbólico
                linkParent.content[linkFileName] = {
                    type: 'l',
                    permissions: 'lrwxrwxrwx',
                    owner: currentState.currentUser,
                    group: currentState.currentUser,
                    content: '',
                    link: targetPath,
                    date: getCurrentDate()
                };
            } else {
                // Hard link (simplificado - apenas cópia)
                linkParent.content[linkFileName] = JSON.parse(JSON.stringify(targetFile));
                linkParent.content[linkFileName].owner = currentState.currentUser;
                linkParent.content[linkFileName].group = currentState.currentUser;
                linkParent.content[linkFileName].date = getCurrentDate();
            }
            
            return '';
        }

        function cmdTar(args) {
            let create = false;
            let extract = false;
            let file = null;
            let verbose = false;
            let compress = false;
            
            // Processar opções
            for (let i = 0; i < args.length; i++) {
                const arg = args[i];
                
                if (arg.startsWith('-')) {
                    if (arg.includes('c')) create = true;
                    if (arg.includes('x')) extract = true;
                    if (arg.includes('v')) verbose = true;
                    if (arg.includes('z')) compress = true;
                    if (arg.includes('f') && i + 1 < args.length) {
                        file = args[i + 1];
                        i++;
                    }
                }
            }
            
            if (!file) {
                return 'tar: É preciso especificar um dos seguintes modificadores: -A, -c, -d, -r ou -t\nTente \'tar --help\' ou \'tar --usage\' para mais informações.';
            }
            
            if (!create && !extract) {
                return 'tar: Você deve especificar uma das opções -c ou -x\nTente \'tar --help\' ou \'tar --usage\' para mais informações.';
            }
            
            if (create) {
                // Não implementado - apenas simulação
                return verbose ? 'tar: Arquivo criado com sucesso.' : '';
            } else if (extract) {
                // Não implementado - apenas simulação
                return verbose ? 'tar: Arquivo extraído com sucesso.' : '';
            }
            
            return '';
        }

        function cmdGzip(args) {
            if (args.length === 0) {
                return 'gzip: faltando arquivo operando\nTente \'gzip --help\' para mais informações.';
            }
            
            // Não implementado - apenas simulação
            return '';
        }

        function cmdGunzip(args) {
            if (args.length === 0) {
                return 'gunzip: faltando arquivo operando\nTente \'gunzip --help\' para mais informações.';
            }
            
            // Não implementado - apenas simulação
            return '';
        }

        function cmdHead(args, inputContent) {
            let lines = 10;
            let files = [];
            
            // Processar opções
            for (let i = 0; i < args.length; i++) {
                if (args[i] === '-n' && i + 1 < args.length) {
                    lines = parseInt(args[i + 1]);
                    i++;
                } else if (args[i].startsWith('-') && !isNaN(parseInt(args[i].substring(1)))) {
                    lines = parseInt(args[i].substring(1));
                } else {
                    files.push(args[i]);
                }
            }
            
            if (files.length === 0 && !inputContent) {
                return 'head: erro ao ler da entrada padrão: Nenhuma entrada';
            }
            
            let results = [];
            
            if (inputContent) {
                const contentLines = inputContent.split('\n');
                return contentLines.slice(0, lines).join('\n');
            }
            
            for (const file of files) {
                const targetPath = resolvePath(file);
                const targetFile = getDirectoryContents(targetPath);
                
                if (!targetFile) {
                    results.push(`head: não foi possível abrir '${file}' para leitura: Arquivo ou diretório não encontrado`);
                    continue;
                }
                
                if (targetFile.type === 'd') {
                    results.push(`head: erro ao ler '${file}': É um diretório`);
                    continue;
                }
                
                if (files.length > 1) {
                    results.push(`==> ${file} <==`);
                }
                
                const contentLines = targetFile.content.split('\n');
                results.push(contentLines.slice(0, lines).join('\n'));
                
                if (files.length > 1) {
                    results.push('');
                }
            }
            
            return results.join('\n');
        }

        function cmdTail(args, inputContent) {
            let lines = 10;
            let follow = false;
            let files = [];
            
            // Processar opções
            for (let i = 0; i < args.length; i++) {
                if (args[i] === '-n' && i + 1 < args.length) {
                    lines = parseInt(args[i + 1]);
                    i++;
                } else if (args[i].startsWith('-') && !isNaN(parseInt(args[i].substring(1)))) {
                    lines = parseInt(args[i].substring(1));
                } else if (args[i] === '-f' || args[i] === '--follow') {
                    follow = true;
                } else {
                    files.push(args[i]);
                }
            }
            
            if (files.length === 0 && !inputContent) {
                return 'tail: erro ao ler da entrada padrão: Nenhuma entrada';
            }
            
            let results = [];
            
            if (inputContent) {
                const contentLines = inputContent.split('\n');
                return contentLines.slice(-lines).join('\n');
            }
            
            for (const file of files) {
                const targetPath = resolvePath(file);
                const targetFile = getDirectoryContents(targetPath);
                
                if (!targetFile) {
                    results.push(`tail: não foi possível abrir '${file}' para leitura: Arquivo ou diretório não encontrado`);
                    continue;
                }
                
                if (targetFile.type === 'd') {
                    results.push(`tail: erro ao ler '${file}': É um diretório`);
                    continue;
                }
                
                if (files.length > 1) {
                    results.push(`==> ${file} <==`);
                }
                
                const contentLines = targetFile.content.split('\n');
                results.push(contentLines.slice(-lines).join('\n'));
                
                if (follow) {
                    results.push('\n[Esperando por mudanças...]');
                }
                
                if (files.length > 1 && !follow) {
                    results.push('');
                }
            }
            
            return results.join('\n');
        }

        function cmdWc(args, inputContent) {
            let countLines = false;
            let countWords = false;
            let countChars = false;
            let countBytes = false;
            let files = [];
            
            // Se não houver opções, contar tudo
            if (args.length === 0 || !args.some(arg => arg.startsWith('-'))) {
                countLines = true;
                countWords = true;
                countBytes = true;
            }
            
            // Processar opções
            args.forEach(arg => {
                if (arg === '-l') {
                    countLines = true;
                } else if (arg === '-w') {
                    countWords = true;
                } else if (arg === '-m') {
                    countChars = true;
                } else if (arg === '-c') {
                    countBytes = true;
                } else if (!arg.startsWith('-')) {
                    files.push(arg);
                }
            });
            
            let results = [];
            
            if (inputContent) {
                let line = '';
                
                if (countLines) {
                    const lines = inputContent.split('\n').length;
                    line += lines.toString().padStart(7) + ' ';
                }
                
                if (countWords) {
                    const words = inputContent.split(/\s+/).filter(Boolean).length;
                    line += words.toString().padStart(7) + ' ';
                }
                
                if (countChars) {
                    const chars = inputContent.length;
                    line += chars.toString().padStart(7) + ' ';
                }
                
                if (countBytes) {
                    const bytes = inputContent.length;
                    line += bytes.toString().padStart(7) + ' ';
                }
                
                return line.trim();
            }
            
            let totals = { lines: 0, words: 0, chars: 0, bytes: 0 };
            
            for (const file of files) {
                const targetPath = resolvePath(file);
                const targetFile = getDirectoryContents(targetPath);
                
                if (!targetFile) {
                    results.push(`wc: ${file}: Arquivo ou diretório não encontrado`);
                    continue;
                }
                
                if (targetFile.type === 'd') {
                    results.push(`wc: ${file}: É um diretório`);
                    continue;
                }
                
                const content = targetFile.content;
                let line = '';
                
                if (countLines) {
                    const lines = content.split('\n').length;
                    line += lines.toString().padStart(7) + ' ';
                    totals.lines += lines;
                }
                
                if (countWords) {
                    const words = content.split(/\s+/).filter(Boolean).length;
                    line += words.toString().padStart(7) + ' ';
                    totals.words += words;
                }
                
                if (countChars) {
                    const chars = content.length;
                    line += chars.toString().padStart(7) + ' ';
                    totals.chars += chars;
                }
                
                if (countBytes) {
                    const bytes = content.length;
                    line += bytes.toString().padStart(7) + ' ';
                    totals.bytes += bytes;
                }
                
                line += file;
                results.push(line);
            }
            
            // Adicionar total se mais de um arquivo
            if (files.length > 1) {
                let totalLine = '';
                
                if (countLines) {
                    totalLine += totals.lines.toString().padStart(7) + ' ';
                }
                
                if (countWords) {
                    totalLine += totals.words.toString().padStart(7) + ' ';
                }
                
                if (countChars) {
                    totalLine += totals.chars.toString().padStart(7) + ' ';
                }
                
                if (countBytes) {
                    totalLine += totals.bytes.toString().padStart(7) + ' ';
                }
                
                totalLine += 'total';
                results.push(totalLine);
            }
            
            return results.join('\n');
        }

        function cmdSort(args, inputContent) {
            let reverse = false;
            let numeric = false;
            let files = [];
            
            // Processar opções
            args.forEach(arg => {
                if (arg === '-r' || arg === '--reverse') {
                    reverse = true;
                } else if (arg === '-n' || arg === '--numeric-sort') {
                    numeric = true;
                } else if (!arg.startsWith('-')) {
                    files.push(arg);
                }
            });
            
            let content = '';
            
            if (inputContent) {
                content = inputContent;
            } else if (files.length > 0) {
                for (const file of files) {
                    const targetPath = resolvePath(file);
                    const targetFile = getDirectoryContents(targetPath);
                    
                    if (!targetFile) {
                        return `sort: não foi possível ler '${file}': Arquivo ou diretório não encontrado`;
                    }
                    
                    if (targetFile.type === 'd') {
                        return `sort: ${file}: É um diretório`;
                    }
                    
                    content += targetFile.content + '\n';
                }
            } else {
                return 'sort: nenhum arquivo especificado';
            }
            
            const lines = content.trim().split('\n');
            
            if (numeric) {
                lines.sort((a, b) => {
                    const numA = parseFloat(a);
                    const numB = parseFloat(b);
                    
                    if (isNaN(numA) && isNaN(numB)) {
                        return reverse ? b.localeCompare(a) : a.localeCompare(b);
                    } else if (isNaN(numA)) {
                        return reverse ? -1 : 1;
                    } else if (isNaN(numB)) {
                        return reverse ? 1 : -1;
                    } else {
                        return reverse ? numB - numA : numA - numB;
                    }
                });
            } else {
                lines.sort((a, b) => reverse ? b.localeCompare(a) : a.localeCompare(b));
            }
            
            return lines.join('\n');
        }

        function cmdUniq(args, inputContent) {
            let count = false;
            let skipFields = 0;
            let skipChars = 0;
            let files = [];
            
            // Processar opções
            for (let i = 0; i < args.length; i++) {
                if (args[i] === '-c' || args[i] === '--count') {
                    count = true;
                } else if (args[i] === '-f' || args[i] === '--skip-fields') {
                    if (i + 1 < args.length) {
                        skipFields = parseInt(args[i + 1]);
                        i++;
                    }
                } else if (args[i] === '-s' || args[i] === '--skip-chars') {
                    if (i + 1 < args.length) {
                        skipChars = parseInt(args[i + 1]);
                        i++;
                    }
                } else if (!args[i].startsWith('-')) {
                    files.push(args[i]);
                }
            }
            
            let content = '';
            
            if (inputContent) {
                content = inputContent;
            } else if (files.length > 0) {
                for (const file of files) {
                    const targetPath = resolvePath(file);
                    const targetFile = getDirectoryContents(targetPath);
                    
                    if (!targetFile) {
                        return `uniq: não foi possível ler '${file}': Arquivo ou diretório não encontrado`;
                    }
                    
                    if (targetFile.type === 'd') {
                        return `uniq: ${file}: É um diretório`;
                    }
                    
                    content += targetFile.content + '\n';
                }
            } else {
                return 'uniq: nenhum arquivo especificado';
            }
            
            const lines = content.trim().split('\n');
            const result = [];
            let currentLine = null;
            let currentCount = 0;
            
            for (const line of lines) {
                // Aplicar opções de skip
                let compareLine = line;
                
                if (skipFields > 0) {
                    const fields = compareLine.split(/\s+/);
                    compareLine = fields.slice(skipFields).join(' ');
                }
                
                if (skipChars > 0) {
                    compareLine = compareLine.substring(skipChars);
                }
                
                if (currentLine === null) {
                    currentLine = line;
                    currentCount = 1;
                } else if (compareLine === currentLine) {
                    currentCount++;
                } else {
                    if (count) {
                        result.push(`${currentCount.toString().padStart(7)} ${currentLine}`);
                    } else {
                        result.push(currentLine);
                    }
                    
                    currentLine = line;
                    currentCount = 1;
                }
            }
            
            // Adicionar última linha
            if (currentLine !== null) {
                if (count) {
                    result.push(`${currentCount.toString().padStart(7)} ${currentLine}`);
                } else {
                    result.push(currentLine);
                }
            }
            
            return result.join('\n');
        }

        function cmdWget(args) {
            if (args.length === 0) {
                return 'wget: URL ausente.\nUso: wget [OPÇÃO]... [URL]...';
            }
            
            const url = args[0];
            
            if (!url.startsWith('http://') && !url.startsWith('https://')) {
                return `wget: URL inválida ${url}: Esquema não suportado`;
            }
            
            // Simular download
            const filename = url.split('/').pop() || 'index.html';
            
            loadingElement.style.display = 'flex';
            loadingTextElement.textContent = `Downloading ${url}...`;
            
            let progress = 0;
            const interval = setInterval(() => {
                progress += 10;
                loadingTextElement.textContent = `Downloading ${url}... ${progress}%`;
                
                if (progress >= 100) {
                    clearInterval(interval);
                    loadingElement.style.display = 'none';
                    
                    // Criar arquivo no diretório atual
                    const currentDir = getDirectoryContents(ttys[currentState.currentTTY].currentDir);
                    
                    if (currentDir) {
                        currentDir.content[filename] = {
                            type: '-',
                            permissions: '-rw-r--r--',
                            owner: currentState.currentUser,
                            group: currentState.currentUser,
                            content: `<!DOCTYPE html>\n<html>\n<head>\n  <title>Example Page</title>\n</head>\n<body>\n  <h1>Example Page from ${url}</h1>\n  <p>This is a simulated downloaded page.</p>\n</body>\n</html>`,
                            date: getCurrentDate()
                        };
                    }
                    
                    addOutput(`--2025-06-01 08:30:00--  ${url}`);
                    addOutput(`Resolving ${url.split('/')[2]}... 93.184.216.34`);
                    addOutput(`Connecting to ${url.split('/')[2]}... connected.`);
                    addOutput('HTTP request sent, awaiting response... 200 OK');
                    addOutput(`Length: 1256 (1.2K) [text/html]`);
                    addOutput(`Saving to: '${filename}'`);
                    addOutput('');
                    addOutput(`${filename}          100%[===================>]   1.2K  --.-KB/s    in 0.001s`);
                    addOutput('');
                    addOutput(`2025-06-01 08:30:01 (1.2 MB/s) - '${filename}' saved [1256/1256]`);
                    
                    isExecuting = false;
                    renderPrompt();
                }
            }, 300);
            
            return null;
        }

        function cmdCurl(args) {
            if (args.length === 0) {
                return 'curl: try \'curl --help\' or \'curl --manual\' for more information';
            }
            
            const url = args[0];
            
            if (!url.startsWith('http://') && !url.startsWith('https://')) {
                return `curl: (1) Protocol "${url.split(':')[0]}" not supported or disabled in libcurl`;
            }
            
            let output = false;
            let filename = null;
            
            // Processar opções
            for (let i = 0; i < args.length; i++) {
                if ((args[i] === '-o' || args[i] === '--output') && i + 1 < args.length) {
                    output = true;
                    filename = args[i + 1];
                    i++;
                }
            }
            
            // Simular download
            if (output && filename) {
                loadingElement.style.display = 'flex';
                loadingTextElement.textContent = `Downloading ${url}...`;
                
                setTimeout(() => {
                    loadingElement.style.display = 'none';
                    
                    // Criar arquivo no diretório atual
                    const currentDir = getDirectoryContents(ttys[currentState.currentTTY].currentDir);
                    
                    if (currentDir) {
                        currentDir.content[filename] = {
                            type: '-',
                            permissions: '-rw-r--r--',
                            owner: currentState.currentUser,
                            group: currentState.currentUser,
                            content: `<!DOCTYPE html>\n<html>\n<head>\n  <title>Example Page</title>\n</head>\n<body>\n  <h1>Example Page from ${url}</h1>\n  <p>This is a simulated downloaded page.</p>\n</body>\n</html>`,
                            date: getCurrentDate()
                        };
                    }
                    
                    addOutput(`  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current`);
                    addOutput(`                                 Dload  Upload   Total   Spent    Left  Speed`);
                    addOutput(`100  1256  100  1256    0     0  12560      0  --:--:-- --:--:-- --:--:-- 12560`);
                    
                    isExecuting = false;
                    renderPrompt();
                }, 2000);
                
                return null;
            } else {
                // Exibir conteúdo
                return `<!DOCTYPE html>\n<html>\n<head>\n  <title>Example Page</title>\n</head>\n<body>\n  <h1>Example Page from ${url}</h1>\n  <p>This is a simulated downloaded page.</p>\n</body>\n</html>`;
            }
        }

        function cmdSsh(args) {
            if (args.length === 0) {
                return 'usage: ssh [-46AaCfGgKkMNnqsTtVvXxYy] [-B bind_interface]\n           [-b bind_address] [-c cipher_spec] [-D [bind_address:]port]\n           [-E log_file] [-e escape_char] [-F configfile] [-I pkcs11]\n           [-i identity_file] [-J [user@]host[:port]] [-L address]\n           [-l login_name] [-m mac_spec] [-O ctl_cmd] [-o option] [-p port]\n           [-Q query_option] [-R address] [-S ctl_path] [-W host:port]\n           [-w local_tun[:remote_tun]] destination [command]';
            }
            
            // Simular conexão SSH
            const destination = args[0];
            
            // Verificar formato
            if (!destination.includes('@') && !destination.match(/^[a-zA-Z0-9.-]+$/)) {
                return `ssh: Could not resolve hostname ${destination}: Name or service not known`;
            }
            
            loadingElement.style.display = 'flex';
            loadingTextElement.textContent = `Connecting to ${destination}...`;
            
            setTimeout(() => {
                loadingElement.style.display = 'none';
                addOutput(`ssh: connect to host ${destination} port 22: Connection refused`);
                isExecuting = false;
                renderPrompt();
            }, 2000);
            
            return null;
        }

        function cmdScp(args) {
            if (args.length < 2) {
                return 'usage: scp [-346BCpqrTv] [-c cipher] [-F ssh_config] [-i identity_file]\n           [-J destination] [-l limit] [-o ssh_option] [-P port]\n           [-S program] source ... target';
            }
            
            // Simular cópia SCP
            loadingElement.style.display = 'flex';
            loadingTextElement.textContent = 'Copying files...';
            
            setTimeout(() => {
                loadingElement.style.display = 'none';
                addOutput('scp: Connection refused');
                isExecuting = false;
                renderPrompt();
            }, 2000);
            
            return null;
        }

        function cmdLogout() {
            // Limpar terminal
            ttys[currentState.currentTTY].output = [];
            currentState.currentUser = '';
            
            // Mostrar tela de login
            systemState.stage = 'login';
            showLoginScreen();
        }

        // Funções utilitárias
        function resolvePath(path) {
            if (!path) return ttys[currentState.currentTTY].currentDir;
            
            // Expandir ~ para diretório home
            if (path.startsWith('~')) {
                const homePath = currentState.currentUser === 'root' ? '/root' : `/home/${currentState.currentUser}`;
                path = homePath + path.substring(1);
            }
            
            // Caminho absoluto ou relativo
            let currentDir = ttys[currentState.currentTTY].currentDir;
            
            if (path.startsWith('/')) {
                return normalizePath(path);
            } else {
                return normalizePath(`${currentDir}/${path}`);
            }
        }

        function normalizePath(path) {
            // Normalizar caminho (remover .., ., barras extras)
            const parts = path.split('/').filter(p => p !== '');
            const result = [];
            
            for (let i = 0; i < parts.length; i++) {
                if (parts[i] === '..') {
                    result.pop();
                } else if (parts[i] !== '.') {
                    result.push(parts[i]);
                }
            }
            
            return '/' + result.join('/');
        }

        function getDirectoryContents(path) {
            if (path === '/') {
                return filesystem['/'];
            }
            
            const parts = path.split('/').filter(p => p !== '');
            let current = filesystem['/'];
            
            for (let i = 0; i < parts.length; i++) {
                if (!current || current.type !== 'd' || !current.content[parts[i]]) {
                    return null;
                }
                current = current.content[parts[i]];
            }
            
            return current;
        }

        function getParentDirectory(path) {
            const parts = path.split('/').filter(p => p !== '');
            
            if (parts.length === 0) {
                return null;
            }
            
            // Remover o último elemento (nome do arquivo/diretório)
            parts.pop();
            
            // Se não houver partes, é o diretório raiz
            if (parts.length === 0) {
                return filesystem['/'];
            }
            
            return getDirectoryContents('/' + parts.join('/'));
        }

        function getCurrentDate() {
            const now = new Date();
            const month = now.toLocaleString('default', { month: 'short' });
            const day = now.getDate().toString().padStart(2, '0');
            const time = now.toTimeString().substring(0, 5);
            return `${month} ${day} ${time}`;
        }

        function updateInterfacesFile(iface, ip, mask) {
            const interfacesFile = getDirectoryContents('/etc/network/interfaces');
            
            if (interfacesFile) {
                let content = interfacesFile.content;
                
                // Verificar se já existe configuração para esta interface
                const regex = new RegExp(`iface ${iface} inet (dhcp|static)`);
                const match = content.match(regex);
                
                if (match) {
                    // Atualizar configuração existente
                    const startIdx = content.indexOf(match[0]);
                    let endIdx = content.indexOf('\n\n', startIdx);
                    
                    if (endIdx === -1) {
                        endIdx = content.length;
                    }
                    
                    const oldConfig = content.substring(startIdx, endIdx);
                    const newConfig = `iface ${iface} inet static\n    address ${ip}/${mask}`;
                    
                    content = content.replace(oldConfig, newConfig);
                } else {
                    // Adicionar nova configuração
                    content += `\n\nauto ${iface}\niface ${iface} inet static\n    address ${ip}/${mask}`;
                }
                
                interfacesFile.content = content;
                interfacesFile.date = getCurrentDate();
            }
        }

        function maskToNetmask(mask) {
            // Converter máscara CIDR para notação de endereço
            const bits = parseInt(mask);
            const mask32 = (0xffffffff << (32 - bits)) >>> 0;
            
            return [
                (mask32 >>> 24) & 0xff,
                (mask32 >>> 16) & 0xff,
                (mask32 >>> 8) & 0xff,
                mask32 & 0xff
            ].join('.');
        }

        function netmaskToCIDR(netmask) {
            // Converter notação de endereço para máscara CIDR
            const parts = netmask.split('.').map(Number);
            let cidr = 0;
            
            for (let i = 0; i < parts.length; i++) {
                const num = parts[i];
                for (let j = 7; j >= 0; j--) {
                    if ((num & (1 << j)) !== 0) {
                        cidr++;
                    } else {
                        break;
                    }
                }
            }
            
            return cidr;
        }

        function humanSize(size) {
            const units = ['B', 'K', 'M', 'G', 'T'];
            let unitIndex = 0;
            let adjustedSize = size;
            
            while (adjustedSize >= 1024 && unitIndex < units.length - 1) {
                adjustedSize /= 1024;
                unitIndex++;
            }
            
            return adjustedSize.toFixed(1) + units[unitIndex];
        }

        function setCharAt(str, index, char) {
            if (index > str.length - 1) return str;
            return str.substring(0, index) + char + str.substring(index + 1);
        }

        // Funções para TTYs
        function switchTTY(ttyNum) {
            if (ttyNum < 1 || ttyNum > 6) return;
            
            currentState.currentTTY = ttyNum;
            
            // Atualizar botões
            ttyButtons.forEach(btn => {
                if (parseInt(btn.dataset.tty) === ttyNum) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });
            
            // Se não houver login neste TTY, mostrar tela de login
            if (systemState.stage === 'running' && !ttys[ttyNum].loginDisplayed) {
                currentState.currentUser = '';
                showLoginScreen();
                ttys[ttyNum].loginDisplayed = true;
            } else {
                renderTerminal();
            }
        }

        // Funções para salvar/carregar estado
        function saveState(name = null) {
            if (!systemState.installed) {
                alert('O sistema precisa ser instalado antes de salvar o estado.');
                return;
            }
            
            const savedName = name || `Sessão ${new Date().toLocaleString()}`;
            
            const stateToSave = {
                ttys: ttys,
                currentState: currentState,
                filesystem: filesystem,
                systemState: systemState,
                timestamp: new Date().getTime(),
                name: savedName
            };
            
            // Salvar no localStorage
            try {
                // Obter histórico existente
                let history = JSON.parse(localStorage.getItem('debianTerminalHistory') || '[]');
                
                // Adicionar nova sessão
                history.push({
                    name: savedName,
                    date: new Date().toLocaleString(),
                    timestamp: new Date().getTime(),
                    state: JSON.stringify(stateToSave)
                });
                
                // Limitar tamanho do histórico
                if (history.length > 10) {
                    history = history.slice(-10);
                }
                
                localStorage.setItem('debianTerminalHistory', JSON.stringify(history));
                
                if (autoSave) {
                    localStorage.setItem('debianTerminalState', JSON.stringify(stateToSave));
                }
                
                addOutput(`Sessão salva: ${savedName}`, 'success');
            } catch (e) {
                addOutput(`Erro ao salvar sessão: ${e.message}`, 'error');
            }
        }

        function showHistoryModal() {
            historyList.innerHTML = '';
            
            try {
                const history = JSON.parse(localStorage.getItem('debianTerminalHistory') || '[]');
                
                if (history.length === 0) {
                    historyList.innerHTML = '<div class="no-history">Nenhuma sessão salva encontrada.</div>';
                } else {
                    // Ordenar por data (mais recente primeiro)
                    history.sort((a, b) => b.timestamp - a.timestamp);
                    
                    history.forEach((item, index) => {
                        const historyItem = document.createElement('div');
                        historyItem.className = 'history-item';
                        
                        historyItem.innerHTML = `
                            <div class="history-name">${item.name}</div>
                            <div class="history-date">${item.date}</div>
                            <button class="delete-history" data-index="${index}">&times;</button>
                        `;
                        
                        historyItem.onclick = function(e) {
                            if (e.target.classList.contains('delete-history')) {
                                deleteHistoryItem(parseInt(e.target.dataset.index));
                                e.stopPropagation();
                            } else {
                                loadStateFromHistory(item);
                            }
                        };
                        
                        historyList.appendChild(historyItem);
                    });
                }
                
                historyModal.style.display = 'flex';
            } catch (e) {
                addOutput(`Erro ao carregar histórico: ${e.message}`, 'error');
            }
        }

        function loadStateFromHistory(historyItem) {
            try {
                const state = JSON.parse(historyItem.state);
                restoreState(state);
                historyModal.style.display = 'none';
                addOutput(`Sessão carregada: ${historyItem.name}`, 'success');
            } catch (e) {
                addOutput(`Erro ao carregar sessão: ${e.message}`, 'error');
            }
        }

        function deleteHistoryItem(index) {
            try {
                const history = JSON.parse(localStorage.getItem('debianTerminalHistory') || '[]');
                history.splice(index, 1);
                localStorage.setItem('debianTerminalHistory', JSON.stringify(history));
                
                // Atualizar modal
                showHistoryModal();
            } catch (e) {
                addOutput(`Erro ao excluir item do histórico: ${e.message}`, 'error');
            }
        }

        function restoreState(state) {
            // Restaurar estado
            ttys = state.ttys;
            currentState = state.currentState;
            filesystem = state.filesystem;
            systemState = state.systemState || { installed: true, stage: 'running', firstBoot: false, needsInstall: false };
            
            // Verificar se o sistema está instalado
            localStorage.setItem('debianTerminalInstalled', 'true');
            
            // Mostrar terminal ou login dependendo do estado
            if (systemState.stage === 'running' && currentState.currentUser) {
                loginScreen.style.display = 'none';
                renderTerminal();
            } else {
                systemState.stage = 'login';
                showLoginScreen();
            }
        }
    </script>
